// =====================================================================================
//
//       Filename:  main.c
//
//    Description:  Fichier principal pour la création de rail sur des lignes
//
//        Version:  1.0
//        Created:  04.03.2013 14:54:58
//       Revision:  none
//       Compiler:  clang
//
//         Author:  Loïc BARTOLETTI (), coder@tuxfamily.org
//        Company:
//
// =====================================================================================


#include	<stdlib.h>
#include	<stdio.h>
#include	<math.h>
#include    <float.h>

#define PI   3.14159265358979323846
#define DEGTORAD(deg)   (((deg) * PI) / 180.0)
#define RADTODEG(rad)   (((rad) * 180.0) / PI)


typedef struct
{
    double x,y;
} Point;
typedef struct
{
    Point P[2];
} Ligne;

enum {GAUCHE, DROITE, DOUBLE};

int calc_rails_ligne(Point *p, int nbPoints, Ligne *ret_line, double dist, int orientation);
double calculAngleExistant(Ligne line);
void calculRails(Point p, double angle, double dist, int orientation, Ligne *line, int position);
double distance(Point p1, Point p2);
double calculPente(Point p1, Point p2);
void pointIntermediaire(Point p1, Point p2, Point *p_i);
void printLigne(FILE *fp, Ligne line);

int main ( int argc, char *argv[] )
{

    if( ( ( ((argc-1)%2)!=0) || (argc < 5)) || ((((argc-3)/2)%2)!= 0) )
    {
        fprintf(stderr, "Usage : %s <Point 1 X Y> <Point 2 X Y> ... <distance> <orientation>\n", argv[0]);
        return EXIT_SUCCESS;
    }

    double dist = strtod(argv[argc-2], NULL);
    int orientation = (int)strtol(argv[argc-1], NULL, 10);
    if((orientation < GAUCHE) || (orientation > DOUBLE))
    {
        fprintf(stderr, "Usage : %s <Point 1 X Y> <Point 2 X Y> ... <distance> <orientation>\n", argv[0]);
        fprintf(stderr, "Orientation :");
        fprintf(stderr, "\t\t\t0 = Gauche\n");
        fprintf(stderr, "\t\t\t\t1 = Droite\n");
        fprintf(stderr, "\t\t\t\t2 = Double\n");
        return EXIT_SUCCESS;
    }

    int nbPointsXY = (argc-3); /* Total des valeurs pour créer les points x et y en entrée */
    int nbPoints = (nbPointsXY/2); /* Nombre de point servant pour la structure Point */

    Point p[nbPoints];

    /* remplissage du tableau */
    int i, j;
    for(i = 0, j = 1; i < nbPoints; i++, j++)
    {
        p[i].x = strtod(argv[j], NULL);
        p[i].y = strtod(argv[++j], NULL);
    }
    
    Ligne *line;
/*    int nbLigne_fig = (nbPoints)+1;*/
    int nbLigne_Rail = (nbPoints-1)*2;

    line = malloc(sizeof(Ligne)* (unsigned long)nbLigne_Rail);
    if ( line == NULL )
    {
        fprintf(stderr,"Allocation Impossible");
        return -1;
    }
    int nbLignerail_ret = calc_rails_ligne(p, nbPoints, line, dist, orientation);
    fprintf(stderr, "nbLigne_Rail = %d\n", nbLigne_Rail);
    fprintf(stderr, "nbLignerail_ret = %d\n", nbLignerail_ret);
    /*
        Point p_inter;

        pointIntermediaire(p_1, p_2, &p_inter);
    */

    /* Pour WKT */
    fprintf(stdout, "WKT\n");

    for(i=0; i<nbLigne_Rail; i++)
    {
        fprintf(stdout, "MULTILINESTRING (");
        printLigne(stdout, line[i]);
        fprintf(stdout, ")\n");
        /*if(i<nbLigne-1)
            fprintf(stdout, ",");*/
    }

    free (line);
    return EXIT_SUCCESS;
}				// ----------  end of function main  ----------

void printLigne(FILE *fp, Ligne line)
{
    /* Précision pouvant être corrigée */
    fprintf(fp, "(%.15lf %.15lf,", line.P[0].x, line.P[0].y);
    fprintf(fp, "%.15lf %.15lf)", line.P[1].x, line.P[1].y);
}

int calc_rails_ligne(Point *p, int nbPoints, Ligne *ret_line, double dist, int orientation)
{

    int i=0, nbLigne = 0;
    Ligne line_points;


    for(i=0; i < nbPoints; )
    {
        line_points.P[0].x = p[i].x;
        line_points.P[0].y = p[i].y;

        i++;
        line_points.P[1].x = p[i].x;
        line_points.P[1].y = p[i].y;

        double corr_angle = DEGTORAD(90);
        if(line_points.P[0].x < line_points.P[1].x)
            corr_angle = -corr_angle;

        calculRails(line_points.P[0], corr_angle+calculAngleExistant(line_points), dist, orientation, ret_line, nbLigne);
        ret_line++;
        nbLigne++;

        calculRails(line_points.P[1], corr_angle+calculAngleExistant(line_points), dist, orientation, ret_line, nbLigne);
        ret_line++;
        nbLigne++;


    }
    return nbLigne;

}
double calculAngleExistant(Ligne line)
{

    /****************************************/
    /*                                      *
     *                                      *
     *         /Pc                          *
     *        /                             *
     *       /\                             *
     *      A\| Alpha : 90°                 *
     *      | \                             *
     *      |  \                            *
     *      |   \                           *
     *     C|____B                          *
     *                                      */
    /****************************************/

    double a = calculPente(line.P[0], line.P[1]);
    double distance_p1p2 = distance(line.P[0], line.P[1]); /* Calcul de la distance AB */
    double distance_adjacent = fabs(line.P[1].y - line.P[0].y); /* Calcul de la distance AC*/
    double angle_CAB = acos(distance_adjacent/distance_p1p2); /* Calcul de l'angle CÂB */

    /* correction avec l'angle existant */
    if (a<0)
    {
        angle_CAB = angle_CAB - PI/2;
    }
    else if (a>0)
    {
        angle_CAB = PI/2 -angle_CAB;
    }
    else
    {
        angle_CAB = 0.0;
    }

    return angle_CAB;
}

void calculRails(Point p, double angle, double dist, int orientation, Ligne *line, int position)
{
    Point p_g = p, p_d = p; /* Initialisation si problème permet d'éviter un if imbriqué */

    /* Calcul droite */
    if((orientation == DROITE) || (orientation==DOUBLE))
    {
        p_g.x = p.x + dist*cos(angle);
        p_g.y = p.y + dist*sin(angle);
    }
    /* Calcul gauche */
    if((orientation == GAUCHE) || (orientation == DOUBLE))
    {
        p_d.x = p.x + -dist*cos(angle);
        p_d.y = p.y + -dist*sin(angle);
    }

    (*line).P[0] = p_g;
    (*line).P[1] = p_d;

}
void pointIntermediaire(Point p1, Point p2, Point *p_i)
{
    (*p_i).x = (p1.x+p2.x)/2.0;
    (*p_i).y = (p1.y+p2.y)/2.0;

    return;

}
double distance(Point p1, Point p2)
{
    return (sqrt(pow(p1.x-p2.x,2.0)+pow(p1.y-p2.y,2.0)));
}

double calculPente(Point p1, Point p2)
{
    return (p1.y - p2.y)/(p1.x - p2.x);
}
