// =====================================================================================
//
//       Filename:  conversion_viasis_csv.c
//
//    Description:  Moulinette pour convertir les données du Viasis en un tableau CSV
//
//        Version:  1.0
//        Created:  19.11.2012 09:25:54
//       Revision:  none
//       Compiler:  clang
//
//         Author:  Loïc BARTOLETTI (), loic.bartoletti@megeve.fr
//        Company:  Mairie de Megève
//
// =====================================================================================


#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <math.h>

#define NB_CHAR 256
#define MAX_CHAR_VITESSES 5

typedef struct
{
    long nb_vitesse;
    char date[11];
    char heure[9];
} st_sisdata;
typedef struct
{
    long min;
    long max;
    float mid;
    long v85;
    long v50;
    long v30;
} st_data_vitesses;

int compare(const void *a, const void *b);
int compte_nb_ligne_fichier(FILE *fp);
int conversion_viasis(char *sisdata, char *sisspeed);
void usage (char *nom_prog);
int copie_vitesses_sisspeed(char *buffer, FILE *fp, long debut, long fin);
int calcul_data(st_data_vitesses *data_vit, char *vitesses, long nb_vitesses);

int main ( int argc, char *argv[] )
{
    if (argc != 3)
    {
        usage(argv[0]);
        return EXIT_SUCCESS;
    }
    else
    {
        conversion_viasis(argv[1], argv[2]);
    }

    return EXIT_SUCCESS;
}				// ----------  end of function main  ----------


void usage (char *nom_prog)
{
    fprintf(stderr, "Usage : %s <fichier SISDATA> <fichier SISSPEED>\n", nom_prog);
}

int conversion_viasis(char *sisdata, char *sisspeed)
{
    int ret = 1;
    FILE *f_sisdata = NULL;         /* Fichier SISDATA. Format du fichier : NB_VITESSES;JOUR HEURES */
    FILE *f_sisspeed = NULL;        /* Fichier SISSPEED. Format du fichier : VITESSE */
    FILE *f_sortie_gl = NULL;       /* Fichier de sortie global : JOUR;HEURES;NB_VITESSE_TOT;NB_VITESSE_PLAGE;VITESSES */
    if( ((f_sisdata = fopen(sisdata, "r")) == NULL) || ((f_sisspeed = fopen(sisspeed, "r")) == NULL) /* Ouverture des fichiers sisdata et sisspeed en lecture seule */
            || ((f_sortie_gl = fopen("vitesses.csv", "w")) == NULL)   ) /* Création des fichiers vitesses */
    {
        fprintf(stderr, "Erreur lors de l'ouverture des fichiers\n");
        ret = -1;
    }

    if (ret == 1)
    {
        long nb_ligne_sisdata = compte_nb_ligne_fichier(f_sisdata);
        long nb_ligne_sisspeed = compte_nb_ligne_fichier(f_sisspeed);
        if (nb_ligne_sisdata != -1)
            fprintf(stdout, "Nb Ligne sisdata : %ld\n", nb_ligne_sisdata);
        else
            ret = -1;

        if(ret == 1)
        {


            if (nb_ligne_sisspeed != -1)
                fprintf(stdout, "Nb Ligne sispeed : %ld\n", nb_ligne_sisspeed);
            else
                ret = -1;

            if(ret == 1)
            {
                rewind(f_sisdata);
                rewind(f_sisspeed);

                char *ligne = NULL;
                ligne = malloc(NB_CHAR * sizeof(char));
                if (ligne == NULL)
                {
                    fprintf(stderr, "Erreur d'allocation mémoire\n");
                    ret = -1;
                }

                long position = 0;
                long vitesses_lues = 0;
                long vit_prec = 0;
                long vit_en_cours = 0;
                fprintf(f_sortie_gl, "JOUR;HEURES;NB_VITESSE_TOT;NB_VITESSE_PLAGE;VITESSES\n");
                while(fgets(ligne, sizeof(char) * NB_CHAR, f_sisdata) && (ret == 1))      /* on récupère la ligne */
                {
                    st_sisdata sis;
                    /* on va découper la ligne pour récuperer les éléments correctement */
                    /* ex : 1;19/12/2011 10:54:00 deviendra : */
                    /* nb_vitesse = 1 */
                    /* date = 19/12/2011 */
                    /* heure = 10:54:00 ; Si heure = NULL alors heure = 00:00:00 */
                    char *token, *tofree, *string;
                    tofree = string = ligne;
                    assert(string != NULL);
                    long pos_token = 0;
                    char *vitesses = NULL;
                    
                    position += 1;
                    if (position <= nb_ligne_sisdata)
                    {
                        while( (token = strsep(&string, "; \n"))!=NULL)
                        {
                            switch(pos_token)
                            {
                            case 0:
                                sis.nb_vitesse = strtol(token, NULL, 10);
                                vitesses = malloc((size_t)(sis.nb_vitesse*MAX_CHAR_VITESSES) * sizeof(char));
                                if (vitesses == NULL)
                                {
                                    fprintf(stderr, "Erreur d'allocation mémoire\n");
                                    ret = -1;
                                    break;
                                }
                                vit_en_cours = sis.nb_vitesse - vit_prec;
                                if(vit_en_cours > 0)
                                {
                                    if(copie_vitesses_sisspeed(vitesses, f_sisspeed, vit_prec, sis.nb_vitesse) == -1)
                                    {
                                        fprintf(stderr, "Erreur d'allocation mémoire\n");
                                        ret = -1;
                                        break;
                                    }
                                }
                                else
                                {
                                    sprintf(vitesses, "0 "); /* Ajout d'un espace pour les heures sans vitesses sinon R ne peut pas analyser */
                                }
                                vitesses_lues += sis.nb_vitesse - vit_prec;
                                vit_prec = sis.nb_vitesse;
                                break;
                            case 1:
                                sprintf(sis.date, "%s", token);
                                break;
                            case 2:
                                if( (token == NULL) || (strlen(token)==0))
                                {
                                    sis.date[strlen(sis.date)-1]='\0';
                                    sprintf(sis.heure, "00:00:00");
                                }
                                else
                                {
                                    sprintf(sis.heure, "%s", token);
                                    sis.heure[strlen(sis.heure)-1] = '\0';
                                }
                                break;
                            default:
                                break;
                            }
                            pos_token +=1;
                        }

                        if((ret == 1) && (vit_en_cours > 0))
                            fprintf(f_sortie_gl, "%s;%s;%ld;%ld;%s\n", sis.date, sis.heure, sis.nb_vitesse, vit_en_cours, vitesses);
                        free(vitesses);
                    vitesses = NULL;
                    tofree = NULL;
                    token = NULL;
 
                    }
                    
                }

                free(ligne);
                ligne = NULL;
            }
        }
        fclose(f_sisdata);
        fclose(f_sisspeed);
        fclose(f_sortie_gl);

    }
    f_sisdata = NULL;
    f_sisspeed = NULL;
    f_sortie_gl = NULL;
    return ret;
}

/* fonction pour comparer les nombres de type long */
int compare(const void *a, const void *b)
{
    const long *x = a, *y = b;
    if(*x > *y)
        return 1;
    else
        return(*x < *y) ? -1:0;
}

int calcul_data(st_data_vitesses *data_vit, char* vitesses, long nb_vitesses)
{

    char *token, *string, *tofree;
    tofree = string = vitesses;
    assert(string != NULL);
    long pos_token = 0;
    long tab_vitesses[nb_vitesses];

    while( (token = strsep(&string, " "))!=NULL)
    {
        tab_vitesses[pos_token] = strtol(token, NULL, 10);
        pos_token += 1;
    }
    qsort(tab_vitesses, (size_t)nb_vitesses, sizeof(long), compare); /* tri du tableau */
    long sum_vitesses = 0;

    int i;
    for(i = 0; i < nb_vitesses; i++)
    {
        sum_vitesses += tab_vitesses[i];
    }

    data_vit->min = tab_vitesses[0];
    data_vit->max = tab_vitesses[nb_vitesses-1];
    data_vit->mid = (float)(sum_vitesses / nb_vitesses);
    data_vit->v85 = tab_vitesses[(long)round(85*nb_vitesses/100)];
    data_vit->v50 = tab_vitesses[(long)round(50*nb_vitesses/100)];
    data_vit->v30 = tab_vitesses[(long)round(30*nb_vitesses/100)];

    token = NULL;
    tofree = NULL;
    string = NULL;

    return 1;
}

int copie_vitesses_sisspeed(char *buffer, FILE *fp, long debut, long fin)
{
    long i;
    int ret = 1;
    char *ligne = NULL;
    ligne = malloc(NB_CHAR * sizeof(char));
    if (ligne != NULL)
    {
        /* mise à zéro des buffers */
        *ligne = '\0'; 
        *buffer = '\0';
        for(i=debut; i<fin; i++) /* Récupérer les lignes concernées dans SISSPEED */
        {
            fgets(ligne, sizeof(char) * NB_CHAR, fp);

            /* On écrit proprement la chaîne dans le buffer */
            ligne[strlen(ligne)-2] = ' ';
            ligne[strlen(ligne)-1] = '\0';
            strcat(buffer, ligne);
        }
        ret = 1;
    }
    else
    {
        ret = -1; /* Erreur */
    }
    free(ligne);
    ligne = NULL;

    return ret;
}

int compte_nb_ligne_fichier(FILE *fp)
{
    int nb_ligne = 0;            /* variable qui sera retournée pour compter le nombre de lignes */
    char ligne[NB_CHAR];            /* buffer de ligne ; on considère max 255 caractères */
    while(fgets(ligne, sizeof ligne, fp))
    {
        nb_ligne += 1;
    }

    return nb_ligne;            /* on retourne le nombre de lignes du fichier */
}

