/*
 * =====================================================================================
 *
 *       Filename:  simple.c
 *
 *    Description:  Fonctions permettant la manipulation des listes simplement chaînées
 *
 *        Version:  1.0
 *        Created:  29.12.2013 21:02:27
 *       Revision:  none
 *       Compiler:  clang
 *
 *         Author:  Loïc BARTOLETTI (), coder@tuxfamily.org
 *   Organization:
 *
 * =====================================================================================
 */

#include <stdio.h>
#include <stdlib.h>
#include "simple.h"

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  *liste_new(void);
 *  Description:
 * =====================================================================================
 */
SList *SList_new(void)
{
    SList *p_liste = malloc(sizeof *p_liste);

    if(p_liste)
    {
            p_liste->start = NULL;
            p_liste->elem = NULL;
            p_liste->nb_elem = 0;
        
    }
    else
    {
        fprintf(stderr, "Mémoire insufisante\n");
        return NULL;
    }

    return p_liste;
}		/* -----  end of function *liste_new(void);  ----- */


/*
 * ===  FUNCTION  ======================================================================
 *         Name:  add_elem
 *  Description:
 * =====================================================================================
 */
int SList_append( SList *list, void *data)
{
    if(list)
    {
        /* Création des éléments */
        SList_elem *dernier = list->elem;
        SList_elem *nouveau = NULL;

        nouveau = malloc(sizeof *nouveau);
        if(nouveau)
        {
            nouveau->data = (void*)data;
            /* si la liste est vide */
            if(list->elem == NULL)
            {
                list->start = nouveau;
                nouveau->next = NULL;
            }
            else
            {
                nouveau->next = dernier->next;
                dernier->next = nouveau;
            }
            list->elem = nouveau; 
            list->nb_elem++;

        }
        else
        {
            fprintf(stderr, "Mémoire insuffisante\n");
            return -1;
        }
    }
    return 1;
}		/* -----  end of function add_elem  ----- */

int SList_prepend( SList *list, void *data)
{
    SList_elem *nouveau = NULL;
    SList_elem *premier = list->start;
    nouveau = malloc(sizeof *nouveau);
    if(nouveau)
    {
        nouveau->data = (void*)data;
        if(list)
        {
            nouveau->next = premier;
            list->start = nouveau;
            list->nb_elem++;
        }
        else /*  chaîne nouvelle  */
        {
            return SList_append(list, data);
        }
    }
    else
    {
        fprintf(stderr, "Mémoire insuffisante\n");
        return -1;
    }
    return 1;
}
int SList_insert( SList *list, void *data, unsigned int position)
{
    SList_elem *nouveau = NULL;
    if (position == 0)
        SList_prepend(list, data);
    else if(position >= list->nb_elem)
        SList_append(list, data);
    else
    {
        list->elem = list->start;
        
        nouveau = malloc(sizeof *nouveau);
        if(nouveau)
        {
            int i;
            for(i=0; i<position-1; i++)
            {
                list->elem = list->elem->next;
            }

            nouveau->data = (void*)data;
            SList_elem *sentinelle = list->elem;

            nouveau->next = sentinelle->next;
            sentinelle->next = nouveau;

            list->elem = nouveau; 
            list->nb_elem++;

        }
    }

    return 0;
}
int SList_remove( SList *list, void *data)
{
    return 0;
}
int SList_remove_all( SList *list, void *data)
{
    return 0;
}
void SList_free( SList *list)
{
}
int SList_reverse(SList *list)
{
    return 0;
}
unsigned int SList_first(SList *list)
{
    return 0;
}
unsigned int SList_last(SList *list)
{
    return 0;
}
unsigned int SList_index(SList *list, void* data)
{
    return 0;
}
