/*
    brute_force :  Example of brute forcing algorithm.
    Copyright (C) 2009-2010 Loïc Bartoletti
    http://coder.tuxfamily.org/

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
     the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

    Loïc Bartoletti
    coder@tuxfamily.org
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>
#include <float.h>
#include <omp.h>

int brute_force(char *charset, int nbChar);
void usage(char *nom_soft);

int brute_force(char *charset, int nbChar)
{

    int lenAlph = strlen(charset);

    int position[nbChar];
    int i,z;
#pragma omp for
    for (i = 0; i <  nbChar; i++)
        position[i] = 0;
    double nbPass;
    if (nbChar >= 3)
        nbPass = pow((double)lenAlph,(double)nbChar)-1;
    else
        nbPass = pow((double)lenAlph,(double)nbChar);



    double tailleKo, tailleMo, tailleGo;
    tailleKo = ((double)nbPass*((double)nbChar+2))/1024;
    tailleMo = tailleKo /1024;
    tailleGo = tailleMo /1024;
    fprintf(stderr, "Pour %.0f mots\nVous devez disposer d'environ : %.2f Ko soit %.2f Mo soit %.2f Go\n", nbPass, tailleKo, tailleMo, tailleGo);
    for(i=0; i < nbPass; i++)
    {
#pragma omp for 
        for(z=0; z < nbChar; z++)
        {
            printf("%c", charset[position[z]]);
            position[z] += 1;

            int j = z;
            while(j >= 0)
            {
                if (position[j] == lenAlph)
                {
                    position[j] = 0;
                    position[j-1] +=1;
                }
                j--;
            }


        }
        puts("");
    }

    return nbPass;
}

void usage(char *nom_soft)
{
    fprintf(stderr, "Usage : %s <min> <max> (-c Charset) (-m|-u output)\n", nom_soft);
    fprintf(stderr, "min : Minimum length of words\n");
    fprintf(stderr, "max : Maximum length of words\n");
    fprintf(stderr, "Alphabet : caracters of the charset. Default is \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n");
    fprintf(stderr, "Output : -m : one file for each length\n");
    fprintf(stderr, "         -u : a single file\n");
    fprintf(stderr, "         default output is screen\n");
}

int main (int argc, char *argv[])
{
    int min, max;
    if ((argc <3) || (argc >7))
    {
        usage(argv[0]);
        exit(EXIT_FAILURE);
    }

    min = (int)strtol(argv[1], NULL,10);
    max = (int)strtol(argv[2],NULL,10);

    int i;
    if(max < min)
    {
        int tmp = min;
        min = max;
        max = tmp;
    }




    clock_t start, end;
    double elapsed;

    start = clock();                                  /* Lancement de la mesure */
    int nbPass = 0;
#pragma omp parallel for private(i)
    for(i=min; i<=max; i++)
    {
        if ((argc == 5) && (strncmp(argv[3],"-c",(size_t)2)==0))
        {
            nbPass += brute_force(argv[4], i);
        }
        else if ((argc == 7) && (strncmp(argv[5],"-c",(size_t)2)==0))
        {
            nbPass += brute_force(argv[6], i);
        }
        else
        {
            nbPass += brute_force((char*)"ABCDEFGHIJKLMNOPQRSTUVWXYZ", i);
        }
    }


    fprintf(stderr, "FINISH\n");
    end = clock();                                    /* Arret de la mesure     */

    elapsed = ((double)end - start) / CLOCKS_PER_SEC; /* Conversion en seconde  */

    fprintf(stderr, "%d mots générés en %.2f secondes.\n", nbPass, elapsed);

    return EXIT_SUCCESS;
}


