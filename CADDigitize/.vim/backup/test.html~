
      <h1 class="title">Les <var style="display:none"> C++:bases de la programmation</var>bases de la programmation C++</h1>
      <p class="defaut">Nous allons maintenant découvrir
comment C++ permet d’implémenter des algorithmes.
Ce langage appartient à la famille des langages procéduraux,
ce qui signifie que les instructions d’un programme sont regroupées
pour former des procédures - que l’on appelle
aussi fonctions.</p>
      <p class="defaut">Un programme C++ utilise
d’une part des variables pour ranger des valeurs et d’autre part
des instructions pour faire évoluer ces valeurs. Ce n’est
pas l’aspect le plus original de C++ puisqu’il
partage cette base "algorithmique" avec le langage C. De ce fait,
de nombreux types de données sont communs aux deux langages
et les instructions de base sont également identiques.
Ceci facilite l’apprentissage du langage C++ et
améliore la portabilité ascendante.</p>
      <p class="defaut">Signalons aussi que la syntaxe C++ est
un peu plus souple que celle du C, notamment&nbsp;en ce qui
concerne la déclaration des variables et des paramètres. La
relecture des programmes s’en trouve naturellement améliorée.</p>
      <p class="defaut">Pour le lecteur qui découvre la programmation
orientée objet avec C++ &nbsp;il
est essentiel d’assimiler pleinement la programmation fonctionnelle,
c’est-à-dire à base de fonctions. Connaître
les algorithmes de base - recherches, tris - est
un très bon moyen d’y parvenir. La programmation orientée
objet est un sur ensemble de la programmation fonctionnelle, une
façon particulière de la structurer, de l’exploiter.
Mais les règles de base demeurent les mêmes.</p>
      <p class="defaut">Avant toute instruction et toute déclaration
de variable, expliquons la notation des commentaires.</p>
      <p class="defaut">Les commentaires sont des annotations rédigées
par celui qui programme. Ils facilitent la relecture et rappellent
parfois le rôle de certaines variables ou de certains blocs
d’instructions.</p>
      <p class="defaut">Le langage C++ connaît
deux types de <var style="display:none"> Commentaires</var>commentaires&nbsp;: les commentaires sur une seule
ligne et ceux qui occupent plusieurs lignes.</p>
      <p class="defaut">Pour le premier type, on utilise la barre
oblique redoublée. Le compilateur qui reconnaît
cette séquence <span class="courier_gras_11">//</span> ignore
tout ce qui suit jusqu’à la fin de la ligne.</p>
      <p class="defaut">Le second type est délimité par
les séquences <span class="courier_gras">/*</span> et <span class="courier_gras">*/</span>, ce qui autorise
l’annotation sur plusieurs lignes ou bien sur une partie de ligne
seulement, comme en langage C. Attention, l’utilisation de commentaires
imbriqués <span class="courier_gras_11">/* ...... /* ... */ ......*/</span> n’est
pas toujours acceptée par le compilateur.</p>
      <p class="defaut">Les commentaires peuvent être placés
dans n’importe quel fichier source C++.</p>
      <div class="sect2">
        <h2 class="title">1. <var style="display:none"> Déclaration:de variables</var>Déclaration de variables</h2>
        <div class="sect3">
          <h3 class="title">a. Utilité des variables</h3>
          <p class="defaut">Il existe plusieurs sortes de variables. Selon
l’emploi qui leur est destiné, on déterminera&nbsp;un
nom, une portée, un type et parfois même une valeur
initiale. Ce sont les algorithmes qui font ressortir la nécessité d’employer
des variables.</p>
          <p class="defaut">Lorsque vous créez une variable,
vous devez toujours choisir le nom le plus explicite&nbsp;qui
soit, même s’il est un peu long. D’une part, les éditeurs
de code source disposent presque tous d’une fonction de complétion,
d’autre part la lisibilité&nbsp;d’un programme est
l’objectif numéro un.</p>
          <p class="defaut">Ainsi, pour représenter les dimensions
d’un meuble, préférez les noms largeur, hauteur
et profondeur aux noms sibyllins l, L et P.</p>
          <p class="defaut">Pour les boucles, on préfèrera
des identificateurs (noms) plus courts, comme i, j, k à condition
que leur portée soit limitée. Il est hors de question
de déclarer une variable i dans une portée globale,
ce serait beaucoup trop dangereux pour le fonctionnement des algorithmes.</p>
          <p class="defaut">Il est également important de souligner
qu’une variable voit sa valeur évoluer au cours du temps.
Une variable peut donc servir à recueillir une valeur disponible à un
moment donné et à mémoriser cette valeur
autant de temps que nécessaire. Ce résultat pourra
soit évoluer - la valeur de variable est modifiée - soit
concourir à l’élaboration d’une autre valeur en évaluant
une expression où elle intervient.</p>
          <div class="table">
            <table class="informaltable" style="max-width:90%" align="left" border="1" bordercolor="black" width="90%">
              <colgroup>
                <col title="1" width="32.817460317460316%">
                <col title="2" width="67.18253968253968%">
              </colgroup>
              <tbody class="tbody">
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">Variable d’ordre général</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">Représente une caractéristique
attachée à un objet naturel, comme une largeur,
un poids ou un prix. L’unité - mètre,
kilogramme ou euro&nbsp;- n’est pas mémorisée
par la variable elle-même. Sa valeur évolue généralement
peu.</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">Variable discrète</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">Sa valeur évolue régulièrement
dans une plage de valeurs, de 1 à 15 par exemple. Permet
de réaliser une action un certain nombre de fois.</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">Variable intermédiaire</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">Sa valeur est actualisée en
fonction de certains calculs. Une somme constitue un bon exemple
de ce type de variable.</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p class="defaut">Le moyen le plus simple pour faire évoluer
la valeur d’une variable est l’affectation, désignée
par l’opérateur <span class="courier11">=</span>.
La variable est placée à gauche du signe <span class="courier11">=</span> et la valeur à droite.
On parle de l-value (left-value) et de r-value (right-value).</p>
          <pre class="programlisting">aire = largeur * longueur ;
</pre>
          <p class="defaut">Il existe d’autres moyens que l’affectation
pour intervenir sur la valeur d’une variable, moyens que l’on désigne
par effets de bord. La portée est une caractéristique
déterminante pour protéger une variable contre
une écriture malencontreuse.</p>
          <p class="defaut">Seule la valeur d’une variable est modifiable.
Son type, sa portée et même son nom sont définis
une fois pour toutes lors de sa déclaration.</p>
        </div>
        <div class="sect3">
          <h3 class="title">b. <var style="display:none"> Portée des variables</var>Portée des variables</h3>
          <p class="defaut">Une variable perd son contenu lorsque le flot
d’exécution quitte sa portée de déclaration.
Lorsqu’il s’agit d’une portée globale, elle perd son contenu
lorsque l’exécution du programme prend fin.</p>
          <p class="defaut">La déclaration des variables est
obligatoire dans un programme C++. Il n’est pas
possible d’utiliser une variable non déclarée,
le compilateur soulève dans ce cas une erreur. Seuls les
langages interprétés disposent de cette caractéristique,
comme <var style="display:none"> Basic</var>Basic ou <var style="display:none"> PHP</var>PHP.</p>
          <p class="defaut">La déclaration d’une variable spécifie
toutes ses caractéristiques en une seule étape.</p>
          <p class="defaut">L’endroit où s’effectue cette déclaration
détermine la portée de la variable, c’est-à-dire
la région dans le code où elle a du sens. Hors
de sa portée, il peut être impossible d’y accéder
pour lire sa valeur ou pour la modifier.</p>
          <p class="defaut">La variable peut très bien aussi
ne plus exister lorsqu’elle est considérée hors de
sa portée.</p>
          <div class="table">
            <table class="informaltable" style="max-width:90%" align="left" border="1" bordercolor="black" width="90%">
              <colgroup>
                <col title="1" width="27.346695772970825%">
                <col title="2" width="72.65330422702918%">
              </colgroup>
              <tbody class="tbody">
                <tr class="RowBody">
                  <td class="entry" style="background-color:transparent;text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">Portée
globale</p>
                  </td>
                  <td class="entry" style="background-color:transparent;text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">Variable
dite globale. Est en principe accessible par toutes les fonctions
du programme. Nombreuses occasions de modifications concurrentes,
donc l’usage de cette portée est à limiter le
plus possible.</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="background-color:transparent;text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">Portée
d’un espace  de noms</p>
                  </td>
                  <td class="entry" style="background-color:transparent;text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">Variable
moins globale, car des modificateurs d’accès - <span class="courier_gras"><var style="display:none"> private</var>private</span>, <span class="courier_gras"><var style="display:none"> public</var>public</span> - peuvent être
employés pour limiter son usage hors de l’espace de noms.</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="background-color:transparent;text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">Portée
d’une classe</p>
                  </td>
                  <td class="entry" style="background-color:transparent;text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">Raisonnement
identique à celui de l’espace de noms, hormis le fait que
la variable existe autant de fois que la classe est instanciée.</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="background-color:transparent;text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">Portée
 d’une fonction</p>
                  </td>
                  <td class="entry" style="background-color:transparent;text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">Variable
dite locale. Dévolue à un usage algorithmique. Niveau
de protection assez élevé.</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="background-color:transparent;text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">Portée
d’un bloc d’instructions</p>
                  </td>
                  <td class="entry" style="background-color:transparent;text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">Variable
très locale. Raisonnement identique à la variable recevant
la portée d’une fonction.</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p class="defaut">Dans le tableau ci-dessus, l’appellation portée
locale signifie que la variable est déclarée à l’intérieur
d’une fonction. Dans le cas de la portée d’un espace de noms,
la variable est déclarée à l’intérieur
d’un espace de noms, et ainsi de suite.</p>
          <pre class="programlisting">int v_globale; &nbsp;// variable globale&nbsp;
&nbsp;
namespace Formes&nbsp;
{&nbsp;
 &nbsp;double aire; &nbsp;// portée d’un espace de noms&nbsp;
}&nbsp;
&nbsp;
class Cube&nbsp;
{&nbsp;
 &nbsp;float arrete; &nbsp;// portée d’une classe (champ)&nbsp;
} ;&nbsp;
&nbsp;
void compter()&nbsp;
{&nbsp;
 &nbsp;int i; &nbsp; &nbsp; &nbsp;// variable locale&nbsp;
}
</pre>
          <p class="defaut">Lorsque l’on fait référence à une
variable, le compilateur privilégie toujours celle qui
a la déclaration la plus proche. Autrement dit, si deux
variables portent&nbsp;le même nom, l’une étant
globale et l’autre étant locale à une fonction, la
variable globale sera masquée par la variable locale pour
les expressions situées&nbsp;à l’intérieur
de la fonction&nbsp;:</p>
          <pre class="programlisting">int i; &nbsp; &nbsp; &nbsp;// variable globale&nbsp;
&nbsp;
void compter()&nbsp;
{&nbsp;
 &nbsp;int i; &nbsp; &nbsp;// variable locale&nbsp;
 &nbsp;i=2; &nbsp; &nbsp; &nbsp;// affecte la variable locale&nbsp;
}
</pre>
          <p class="defaut">Pour contourner ce problème, on peut
employer l’opérateur de résolution de portée <span class="courier_gras_11">::</span> qui explicite la portée à laquelle
se rapporte la variable considérée&nbsp;:</p>
          <pre class="programlisting">int i;&nbsp;
void compter()&nbsp;
{&nbsp;
 &nbsp;int i; &nbsp; &nbsp;// variable locale&nbsp;
 &nbsp;i=2; &nbsp; &nbsp; &nbsp;// affecte la variable locale&nbsp;
 &nbsp;<b>::</b>i=8; &nbsp; &nbsp;// variable globale affectée&nbsp;
}
</pre>
          <p class="defaut">Nous trouverons par la suite d’autres emplois
de cet opérateur&nbsp;<span class="courier11">::</span> qui
n’existe pas dans le langage C.</p>
        </div>
        <div class="sect3">
          <h3 class="title">c. Syntaxe de déclaration</h3>
          <p class="defaut">La syntaxe pour déclarer une variable
est très concise :</p>
          <pre class="programlisting">type nom ;
</pre>
          <p class="defaut">Le type et le nom sont obligatoires.</p>
          <p class="defaut">Le point-virgule clôt la déclaration,
il est nécessaire. On trouve parfois aussi une déclaration
procédant à l’initialisation de la variable avec
une valeur&nbsp;:</p>
          <pre class="programlisting">int prix = 30 ; &nbsp;// déclare une variable prix de type entier
</pre>
          <p class="defaut">Il est également possible de partager
le type entre plusieurs variables, dans le but de raccourcir la
séquence de déclaration :</p>
          <pre class="programlisting">int largeur, hauteur ;
</pre>
          <p class="defaut">Naturellement, chaque variable largeur et
hauteur est de type entier (<span class="courier_gras">int</span>). Chacune
d’entre elles peut recevoir une valeur initiale&nbsp;:</p>
          <pre class="programlisting">int largeur = 30, hauteur = 120 ;
</pre>
          <p class="defaut">Le nom de la variable doit commencer par une
lettre ou par le caractère de soulignement. Sont exclus
des identificateurs de variable les caractères assimilés à des
opérateurs, tels que <span class="courier_gras">- + / .
&lt;</span> ainsi que le caractère <span class="courier_gras">$</span>.</p>
          <p class="defaut">Il n’est pas judicieux d’employer des caractères
accentués, même si le compilateur les accepte.
La portabilité du programme serait plus que réduite.</p>
        </div>
        <div class="sect3">
          <h3 class="title">d. <var style="display:none"> Types:de données</var>Types de données</h3>
          <p class="defaut">Le langage C++ reprend les
types primitifs du langage C. Ces types se répartissent
dans différentes catégories : types entiers, types
décimaux, caractères. C++ ajoute
un type booléen et n’améliore pas la représentation
archaïque des chaînes de caractères.
Une classe est plutôt proposée dans la bibliothèque standard
STL mais son emploi n’est pas aussi généralisé que
l’habituel <span class="courier11">char*</span>.</p>
          <p class="defaut">Pour les types dont le codage varie d’un compilateur à l’autre
(<span class="courier11">int</span> par exemple), l’opérateur <span class="courier_gras"><var style="display:none"> sizeof()</var>sizeof()</span> retourne la largeur du
type ou de la variable en octets.</p>
          <p><span class="bridgehead_niv4">Les <var style="display:none"> Types:entiers</var>types entiers</span></p>
          <p class="defaut">Le langage C a été inventé à une époque
où l’informatique était très terre à terre.
Par ailleurs, il a été conçu pour tirer
parti des instructions spécialisées du processeur
animant le PDP-11 (un ancêtre du Vax de Digital). Certaines
notations comme le fameux ++ viennent directement
de cette "optimisation". Côté variable, l’unité de
base reste l’octet. Cette quantité est assez bien placée pour
représenter des caractères ASCII (la table de
base contient 128 symboles) mais aussi des entiers courts, entre
-128 et +127.</p>
          <p class="defaut">Le compilateur utilise la représentation
en complément à deux, ce qui lui permet de traiter
nombres négatifs et soustractions avec la même
arithmétique que l’addition.</p>
          <p class="defaut">Prenons le type <span class="courier11">char</span>,
qui autorise la représentation de 2<sup class="superscript">8 </sup>= 256
valeurs. Ces valeurs sont réparties entre -128 et +127,
en complément à deux. Le complément à deux
est en fait le complément à un (inversion de tous
les bits) augmenté d’une unité. Avec des variables
de type <span class="courier11">char</span>, additionnons 4 et
-3&nbsp;:</p>
          <pre class="programlisting">char x = 4 ;&nbsp;
char y = -3 ;&nbsp;
char z = x + y ;
</pre>
          <p class="defaut">Pour avoir le codage de la valeur 4, c’est-à-dire
de la variable x, il suffit de décomposer&nbsp;en base
2, nous obtenons 1x2<sup class="superscript">2</sup> = 4, donc
:</p>
          <pre class="programlisting">x = 0000 0100
</pre>
          <p class="defaut">Pour avoir le codage de la valeur -3, c’est-à-dire
de la variable y, commençons par écrire 3 en base,
soit 1x2<sup class="superscript">1</sup> + 1x2<sup class="superscript">0</sup> = 3,
soit :</p>
          <pre class="programlisting">+y = 0000 0011
</pre>
          <p class="defaut">Puis inversons tous les bits, nous obtenons
le complément à un :</p>
          <pre class="programlisting">!+y = 1111 1100
</pre>
          <p class="defaut">Ajoutons 1, la représentation de
-3, en binaire et en complément à deux, est&nbsp;:</p>
          <pre class="programlisting">y = 1111 1101
</pre>
          <p class="defaut">À présent, additionnons
x et y&nbsp;:</p>
          <pre class="programlisting">x = 0000 0100&nbsp;
y = 1111 1101
</pre>
          <p class="defaut">L’addition bit à bit, avec propagation
des retenues, donne :</p>
          <pre class="programlisting">z = 0000 0001
</pre>
          <p class="defaut">Ce qui est conforme au résultat attendu.</p>
          <p class="defaut">Le format en complément à deux
a été choisi pour sa simplicité. C++ propose un
certain nombre de types de données pour représenter
des nombres entiers, dont la largeur varie de un à huit
octets, en fonction du microprocesseur.</p>
          <div class="table">
            <table class="informaltable" style="max-width:90%" align="left" border="1" bordercolor="black" width="90%">
              <colgroup>
                <col title="1" width="10.934709267711849%">
                <col title="2" width="27.346695772970825%">
                <col title="3" width="61.71859495931733%">
              </colgroup>
              <tbody class="tbody">
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier_gras_11"><var style="display:none"> char</var>char</span></p>
                  </td>
                  <td class="entry" style="text-align:left;vertical-align:top;">
                    <p class="tableau_texte">256 valeurs  </p>
                    <p class="tableau_texte">[-128 ; +127]</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">Sert aux octets et aux caractères.</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier_gras_11"><var style="display:none"> short</var>short</span></p>
                  </td>
                  <td class="entry" style="text-align:left;vertical-align:top;">
                    <p class="tableau_texte">32768 valeurs  </p>
                    <p class="tableau_texte">[-32 767&nbsp;; +32
768]</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">Entier court, abréviation de <span class="courier_gras">short int</span>. Avec les processeurs
32 bits, son emploi tend à disparaître, sauf pour
des raisons de compatibilité.</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier_gras"><var style="display:none"> int</var>int</span></p>
                  </td>
                  <td class="entry" style="text-align:left;vertical-align:top;">
                    <p class="tableau_texte">2<sup class="superscript">32</sup> valeurs
 </p>
                    <p class="tableau_texte">[-2<sup class="superscript">31</sup>-1
; 2<sup class="superscript">31</sup>-1]</p>
                  </td>
                  <td class="entry" style="background-color:transparent;text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">Entier. En
principe, sa largeur adopte la taille du mot machine, donc 32 bits
le plus souvent.</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier_gras_11"><var style="display:none"> long</var>long</span></p>
                  </td>
                  <td class="entry" style="text-align:left;vertical-align:top;">
                    <p class="tableau_texte">2<sup class="superscript">64</sup> valeurs
 </p>
                    <p class="tableau_texte">[-2<sup class="superscript">63</sup>-1
; 2<sup class="superscript">63</sup>-1]</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">Entier long, abréviation de <span class="courier_gras">long int</span>. En principe le double
de l’<span class="courier11">int</span>, mais parfois limité à 32
bits avec certains compilateurs&nbsp;!</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p class="defaut">L’emploi du qualificateur <span class="courier_gras">unsigned</span> déplace les valeurs
représentées dans l’intervalle [0 ; 2<sup class="superscript">n</sup>-1].
La déclaration d’une variable devient alors :</p>
          <pre class="programlisting"><var style="display:none"> unsigned</var>unsigned char c ;
</pre>
          <p class="defaut">Une des grandes difficultés de portage
d’application C++ vient de la multitude des formats
de représentation attachés aux types. Il est vrai
qu’entre un microcontrôleur 8 bits et un Power PC, le type <span class="courier11">int</span> n’aura pas la même largeur.
Mais cette situation n’est pas toujours avérée
et les compilateurs 16 bits finissent par disparaître.</p>
          <p class="defaut">Pour les variables discrètes - utilisées
dans les boucles for - il peut être opportun d’employer
le type <span class="courier11">int</span>. En effet, les microprocesseurs
32 bits, les plus répandus, doivent ralentir pour traiter
des quantités inférieures. Ils lisent la mémoire
par blocs de quatre octets, voire davantage. Il y a toutes les chances que
la variable soit en fait logée dans un registre du microprocesseur,
mais leur nombre est compté, surtout avec des microprocesseurs
utilisant un registre d’instructions complexe, les <var style="display:none"> CISC</var>CISC, dont le
Pentium fait partie. Par opposition, les processeurs <var style="display:none"> RISC</var>RISC tels que
le Power PC disposent de peu d’instructions mais de beaucoup de
registres. Ils sont donc avantagés par le compilateur pour
traiter les boucles.</p>
          <p class="defaut">Lorsque vous spécifiez une valeur
littérale de type entier, le compilateur utilise la lecture
en base 10. Donc l’affectation <span class="courier11">x = 123</span> signifie
que vous placez la valeur 123 dans la variable x.</p>
          <p class="defaut">Comme C++ reprend les caractéristiques
de C et comme C a été inventé de manière
concomitante d’Unix, le compilateur reconnaît aussi les
bases octale et hexadécimale.</p>
          <p class="defaut">En octal, chaque chiffre évolue entre
0 et 7, puisque la base est 8. Le compilateur reconnaît
l’emploi de l’octal en préfixant la valeur littérale
par un zéro&nbsp;:</p>
          <p class="defaut">x = 0123 équivaut en fait à x = 1x8<sup class="superscript">2</sup> + 2x8<sup class="superscript">1</sup> + 3x8<sup class="superscript">0</sup> soit
83 en décimal.</p>
          <p class="defaut">Le format octal est surtout utile pour représenter
les droits d’accès aux fichiers Unix. Ces droits définissent
la valeur de 3 bits, <span class="courier11">rwx</span> (<span class="courier11">read write execute</span>), ce qui donne
8 possibilités et entraîne l’emploi de la base
octale.</p>
          <p class="defaut">L’hexadécimal est plus commode pour
manipuler la base 2, très risquée pour l’interprétation
humaine. Dans cette base, on utilise les dix chiffres 0 à 9
auxquels on adjoint les lettres A, B, C, D, E et F pour compter
jusqu’à 15. Les seize possibilités d’un digit
hexadécimal font que ce chiffre est équivalent à un quartet,&nbsp;soit
un demi-octet. Le compilateur reconnaît l’emploi de l’hexadécimal
pour une valeur littérale par le préfixe 0x.</p>
          <p class="defaut">Avec a = 0xA28, la variable a reçoit
la valeur 10x16<sup class="superscript">2 </sup>+ 2x16<sup class="superscript">1 </sup>+ 8x16<sup class="superscript">0</sup>,
soit a&nbsp;=&nbsp;600 en décimal.</p>
          <p class="defaut">L’écriture binaire est assez aisée à déduire,
puisque chaque chiffre représente un bloc de quatre bits&nbsp;:</p>
          <pre class="programlisting">1010 0010 1000
</pre>
          <p><span class="bridgehead_niv4">Les <var style="display:none"> Types:décimaux</var>types décimaux</span></p>
          <p class="defaut">Le terme de nombre à virgule flottante
est sans doute plus approprié que celui de réel
choisi pour représenter ce nombre. C++ dispose
des types <span class="courier11">float</span> et <span class="courier11">double</span>, conformes au format IEEE 754.
Ce format standard est surtout employé&nbsp;par les
coprocesseurs arithmétiques.</p>
          <p class="defaut">La précision est loin d’être
bonne, surtout si la valeur absolue des nombres à représenter
est élevée.</p>
          <p class="defaut">Le format <span class="courier11">float</span> utilise
quatre octets pour représenter un nombre à virgule. Le
double multiplie par deux cette quantité. L’intérêt
du double est certainement d’améliorer la précision
des calculs, plus que d’élargir la zone de couverture.</p>
          <p class="defaut">Enfin, le format long double améliore
encore la précision mais le plus souvent donne lieu à des
calculs émulés par un logiciel plutôt
que d’être confiés au coprocesseur&nbsp;arithmétique.</p>
          <div class="table">
            <table class="informaltable" style="max-width:90%" align="left" border="1" bordercolor="black" width="90%">
              <colgroup>
                <col title="1" width="23.43718991863465%">
                <col title="2" width="46.8743798372693%">
                <col title="3" width="29.688430244096054%">
              </colgroup>
              <tbody class="tbody">
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier_gras"><var style="display:none"> float</var>float</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">32 bits, 7 chiffres significatifs</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">+/- 3,4x10<sup class="superscript">38</sup></p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier_gras"><var style="display:none"> double</var>double</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">64 bits, 11 chiffres significatifs</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">+/- 1,7x10<sup class="superscript">308</sup></p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier_gras"><var style="display:none"> long double</var>long double</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">80 bits, 15 chiffres significatifs</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">+/- 1,2x10<sup class="superscript">4932</sup></p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p class="defaut">Avant d’employer ces types dans vos programmes,
ayez à l’esprit les indications suivantes&nbsp;:</p>
          <p class="defaut">Maniez des quantités ayant des valeurs
absolues comparables. Les calculs se faisant avec une mantisse de
40 bits environ, l’addition d’un nombre très grand et d’un
nombre très petit provoquera des erreurs de calcul.</p>
          <p class="defaut">Les nombres entiers sont toujours représentés
exactement avec ces formats.</p>
          <p class="defaut">Certains nombres décimaux tels que
1,45 n’admettent pas de représentation exacte avec les
formats <span class="courier11">float</span> et <span class="courier11">double</span>. Des heuristiques intégrées
aux coprocesseurs arithmétiques tiennent compte de ce phénomène,
mais les calculs peuvent être faux.</p>
          <p class="defaut">La précision diminue rapidement lorsque
la valeur absolue augmente. Utiliser un type <span class="courier11">float</span> à la
limite de sa représentation peut être dramatique
pour la qualité des calculs. Passer à un double
donnera des résultats plus justes, avec un surcroît
de temps de calcul négligeable.</p>
          <p class="defaut">En résumé, ces formats sont
utiles lorsque la compatibilité avec un logiciel extérieur
est en jeu, ou bien lorsque la vitesse des calculs est un facteur
déterminant. Pour les applications scientifiques ou financières,
il peut être utile d’employer une bibliothèque
spécialisée pour représenter les nombres
sous forme de chaînes de caractères.</p>
          <p><span class="bridgehead_niv4">Le <var style="display:none"> Booléen</var>booléen</span></p>
          <p class="defaut">Le langage C ne connaît pas les booléens
en tant que type, mais a détourné l’arithmétique
entière pour évaluer ses prédicats.</p>
          <p class="defaut">Un booléen est une valeur qui est évaluée
comme vraie ou fausse. Les instructions conditionnelles, <span class="courier_gras"><var style="display:none"> if</var>if</span>, <span class="courier_gras"><var style="display:none"> while</var>while</span>, <span class="courier_gras"><var style="display:none"> for</var>for</span>... fonctionnent avec un test
qui doit être de type booléen.</p>
          <p class="defaut">La convention, lorsque les entiers sont utilisés
comme booléens, est que 0 équivaut à faux
et n’importe quelle autre valeur, strictement non nulle, équivaut à vrai.</p>
          <p class="defaut">Comme l’affectation produit une valeur à gauche,
parfois de type entier, les concepteurs ont dû distinguer
l’affectation de la comparaison stricte de deux quantités
:</p>
          <pre class="programlisting">if(x=3)
</pre>
          <p class="defaut">Cette dernière clause est toujours
vérifiée, car 3 est non nul. La variable x reçoit
cette valeur 3, donc le test est positif (vrai). L’écriture
correcte est sans aucun doute&nbsp;:</p>
          <pre class="programlisting">if(x==3)
</pre>
          <p class="defaut">L’opérateur <span class="courier11">==</span> teste
l’égalité de la variable x avec la valeur 3. Il
renvoie vrai ou faux, selon le cas.</p>
          <p class="defaut">Le compilateur C++ soulève
un avertissement (warning) lorsqu’il identifie cette écriture équivoque
mais néanmoins légale d’un point de vue syntaxique. Ceci
dit, le langage C++ dispose aussi d’un vrai type
booléen pour évaluer des prédicats&nbsp;:</p>
          <div class="table">
            <table class="informaltable" style="max-width:90%" align="left" border="1" bordercolor="black" width="90%">
              <colgroup>
                <col title="1" width="12.203179847202147%">
                <col title="2" width="12.203179847202147%">
                <col title="3" width="75.59364030559571%">
              </colgroup>
              <tbody class="tbody">
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier_gras">bool</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier_gras">true false</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">Les valeurs <span class="courier11">true</span> et <span class="courier11">false</span> sont des mots clés
du langage, pas des macros comme on procédait parfois avec
C.</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p><span class="bridgehead_niv4">Les <var style="display:none"> Caractères</var>caractères et les <var style="display:none"> Chaînes</var>chaînes</span></p>
          <p class="defaut">Une chaîne de caractères
est une suite de caractères. Le compilateur range les caractères
les uns après les autres et termine la série par
un caractère de code&nbsp;0. On appelle ce format chaîne
ASCIIZ, avec un Z pour zéro terminal.</p>
          <p class="defaut">Le type qui désigne les chaînes
de caractères est habituellement <span class="courier_gras"><var style="display:none"> char*</var>char*</span>,
mais les tableaux <span class="courier_gras"><var style="display:none"> char[ ]</var>char[&nbsp;]</span> peuvent
aussi convenir sous certaines conditions.</p>
          <p class="defaut">Lorsque l’on désigne une chaîne
littérale, délimitée par les caractères
guillemets, le compilateur alloue une adresse pour stocker les caractères
de la chaîne. Cette adresse est en fait une adresse de
caractère(s), d’où le type <span class="courier11">char*</span>.
Il est naturellement possible de lire cette zone mémoire,
mais la modification des caractères contenus dans cette
zone n’est pas toujours possible, de même que l’écriture
au-delà du zéro terminal.</p>
          <p class="defaut">Il est possible de créer un tableau
de caractères (<span class="courier11">char[&nbsp;]</span>)
assez vaste ou d’allouer une zone mémoire pour recopier
la chaîne littérale et pour se livrer à toutes
les modifications nécessaires.</p>
          <p class="defaut">Le compilateur C++ reconnaît
comme son aîné le C les séquences d’échappement.</p>
          <div class="table">
            <table class="informaltable" style="max-width:90%" align="left" border="1" bordercolor="black" width="90%">
              <colgroup>
                <col title="1" width="7.817460317460317%">
                <col title="2" width="42.182539682539684%">
                <col title="3" width="7.817460317460317%">
                <col title="4" width="42.182539682539684%">
              </colgroup>
              <tbody class="tbody">
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier_gras"><var style="display:none"> n</var>\n</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">Nouvelle ligne</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier_gras"><var style="display:none"> b</var>\b</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">Sonne la cloche (bell)</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier_gras"><var style="display:none"> r</var>\r</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">Retour chariot</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;"><var style="display:none"> t</var><p class="tableau_texte"><span class="courier_gras">\t</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">Tabulation</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p class="defaut">Les valeurs littérales de caractère
sont délimitées par le signe ’ comme l’indique l’extrait
suivant&nbsp;:</p>
          <pre class="programlisting">// trois caractères&nbsp;
char a = 65;&nbsp;
char b = ’B’; &nbsp;// soit le code ASCII 66&nbsp;
char tab = ’\t’;&nbsp;
&nbsp;
// deux chaînes&nbsp;
char* s = "bonjour";&nbsp;
char* u = "comment \n allez-vous ?";
</pre>
          <p class="defaut">Pour la chaîne <span class="courier11">u</span>,
la séquence d’échappement a été "décollée"
pour améliorer la lisibilité. Il est tout à fait
possible de supprimer les espaces de part et d’autre.</p>
          <p class="defaut">Pour copier des chaînes, concaténer
d’autres chaînes, calculer la longueur, effectuer des recherches,
la librairie <span class="courier_gras">&lt;string.h&gt;</span> fournit
toutes les fonctions nécessaires.</p>
          <p class="defaut">Le langage C++ offre aussi
une prise en charge des chaînes plus évoluée
par le biais de sa librairie standard, la STL.</p>
        </div>
      </div>
      <div class="sect2">
        <h2 class="title">2. <var style="display:none"> Instructions:de tests</var>Instructions de tests</h2>
        <p class="defaut">Indispensables à l’énoncé d’un
programme, les opérateurs et les instructions sont les éléments
qui permettent de traduire un algorithme en C++. </p>
        <p class="defaut">Les opérateurs combinent différentes
valeurs pour aboutir à des expressions. Ces expressions
sont de type numérique (entier, décimal) ou booléen.
Lorsque les opérateurs sont surchargés, d’autres
types peuvent découler de l’application d’opérateurs.</p>
        <div class="sect3"><var style="display:none"> Instructions:de tests</var><h3 class="title">a. Instructions de tests</h3>
          <p class="defaut">C++ connaît deux
types de tests&nbsp;: les tests simples et les tests multiples.
Le test simple est un basique de l’algorithme, il s’agit de l’instruction <span class="courier_gras"><var style="display:none"> if</var>if</span>.</p>
          <p class="defaut">Le test multiple a été conçu
afin de tirer parti de l’instruction <span class="courier_gras"><var style="display:none"> switch</var>switch</span> du
PDP-11. Il s’agit d’une optimisation, évitant de tester
plusieurs fois une même valeur&nbsp;entière.
De nos jours, l’instruction <span class="courier11">switch</span> serait
plutôt un confort de programmation, mais nombre de langages
dont C++ fait partie s’en tiennent à l’approche
du langage C.</p>
          <p><span class="bridgehead_niv4">Le test simple, <var style="display:none"> if</var>if</span></p>
          <p class="defaut">Cette instruction exécute conditionnellement
une autre instruction, après évaluation d’un prédicat
booléen. Le style de rédaction est important pour
la lisibilité du programme, mais n’influe pas sur son fonctionnement.</p>
          <pre class="programlisting">if( prédicat ) &nbsp;
 &nbsp; &nbsp;instruction
</pre>
          <p class="defaut">Le décalage d’une tabulation indique
au lecteur que l’instruction n’est exécutée qu’à condition
que le prédicat soit vérifié (vrai).
Une instruction peut représenter plusieurs choses&nbsp;:</p>
          <pre class="programlisting">instruction -&gt; ;&nbsp;
 &nbsp; &nbsp;instruction_simple&nbsp;
 &nbsp; &nbsp;{ instruction instruction_simple }
</pre>
          <p class="defaut">Autrement dit, "instruction" peut désigner
soit l’instruction vide (<span class="courier11">;</span>), soit
une instruction élémentaire comme une affectation
ou un appel de fonction, ou bien être un bloc d’instructions
délimité par les accolades <span class="courier11">{</span> et <span class="courier11">}</span>.</p>
          <p class="defaut">Il est à noter la présence
de parenthèses pour délimiter le prédicat,
ce qui a permis&nbsp;d’éliminer le mot clé <span class="courier11">then</span> prévu par les langages
Basic et Pascal.</p>
          <p class="defaut">Si l’instruction se résume à une
instruction simple, il vaut mieux éviter les accolades&nbsp;pour
ne pas surcharger le programme.</p>
          <pre class="programlisting">if(x==3)&nbsp;
 &nbsp;printf("x vaut 3") ;
</pre>
          <p><span class="bridgehead_niv4">Le test simple avec alternative <var style="display:none"> if ... else</var>if ...
else</span></p>
          <p class="defaut">Il est parfois nécessaire de prévoir
l’alternative, c’est-à-dire l’instruction exécutée
lorsque le prédicat n’est pas vérifié (faux).</p>
          <p class="defaut">C’est précisément la vocation
de la construction <span class="courier_gras">if ... else ...</span>.</p>
          <pre class="programlisting">if(prédicat)&nbsp;
 &nbsp;instruction_vrai&nbsp;
else&nbsp;
 &nbsp;instruction_faux
</pre>
          <p class="defaut">Bien sûr, les règles applicables à la
définition d’une instruction simple ou composée&nbsp;demeurent
vraies : n’employer les accolades que si cela s’avère nécessaire.&nbsp;</p>
          <pre class="programlisting">if(rendez_vous&lt;mercredi)&nbsp;
 &nbsp;printf("rendez-vous en début de semaine");&nbsp;
else&nbsp;
{&nbsp;
 &nbsp;printf("rendez-vous en fin de semaine\n");&nbsp;
 &nbsp;printf("éviter le week-end");&nbsp;
}
</pre>
          <p><span class="bridgehead_niv4">Le test multiple <var style="display:none"> switch</var>switch</span></p>
          <p class="defaut">Le test multiple prévoit les différentes
valeurs que peut prendre une expression (ou une variable). Normalement,
ces valeurs sont de type entier et sont connues au moment de la
compilation.</p>
          <p class="defaut">L’instruction fonctionne en énumérant
les différentes valeurs possibles, appelées&nbsp;cas.
Une clause default s’applique lorsque la valeur testée
n’a satisfait aucun des cas prévus.</p>
          <pre class="programlisting">switch(valeur_entière)&nbsp;
{&nbsp;
 &nbsp;case valeur1:&nbsp;
 &nbsp; &nbsp;instruction&nbsp;
 &nbsp;case valeur2:&nbsp;
 &nbsp; &nbsp;instruction&nbsp;
 &nbsp;...&nbsp;
 &nbsp;default:&nbsp;
 &nbsp; &nbsp;instruction&nbsp;
}
</pre>
          <p class="defaut">En principe, l’instruction doit se terminer
par un break, autrement, l’exécution continue jusqu’à rencontrer
cet arrêt, quitte à franchir de nouvelles lignes
case. Cette construction particulière permet de grouper
plusieurs cas&nbsp;:</p>
          <pre class="programlisting">switch(x)&nbsp;
 &nbsp;{&nbsp;
 &nbsp;case 1:&nbsp;
 &nbsp;case 2:&nbsp;
 &nbsp; &nbsp;printf("x vaut 1 ou 2");&nbsp;
 &nbsp; &nbsp;break;&nbsp;
 &nbsp;case 3:&nbsp;
 &nbsp; &nbsp;printf("x vaut 3");&nbsp;
 &nbsp; &nbsp;break;&nbsp;
 &nbsp;case 10:&nbsp;
 &nbsp; &nbsp;printf("x vaut 10");&nbsp;
 &nbsp; &nbsp;break;&nbsp;
 &nbsp;default:&nbsp;
 &nbsp; &nbsp;printf("x est différent de 1,2 et 10");&nbsp;
 &nbsp; &nbsp;break;&nbsp;
 &nbsp;}
</pre>
          <p class="defaut">La clause default n’a pas besoin de figurer
en dernière position, mais c’est souvent là qu’on
la trouve. Aussi, l’instruction <span class="courier11">switch</span> n’est
pas obligée d’inclure une clause default.</p>
        </div>
        <div class="sect3">
          <h3 class="title">b. <var style="display:none"> Opérateur</var>Opérateurs</h3>
          <p class="defaut">Les opérateurs combinent différentes
valeurs. Suivant le nombre de valeurs réunies par l’opérateur,
on a affaire à des opérateurs unaires ou binaires.
Ces valeurs prennent alors le nom d’opérandes.</p>
          <p class="defaut">Cette section dresse une liste des principaux
opérateurs. Les opérateurs spécifiques
aux classes, aux tableaux et aux fonctions seront abordés
ultérieurement.</p>
          <p><span class="bridgehead_niv4">Opérateurs de <var style="display:none"> Opérateur:comparaison</var>comparaison</span></p>
          <p class="defaut">Ces opérateurs vérifient
une relation d’ordre entre deux opérandes. Les opérandes
peuvent être de n’importe quel type, mais, par souci d’homogénéité,
il vaut mieux que les types soient appariés.</p>
          <p class="defaut">L’évaluation de l’expression faisant
intervenir un opérateur de comparaison produit un résultat
de type booléen, vrai ou faux.</p>
          <div class="table">
            <table class="informaltable" style="max-width:90%" align="left" border="1" bordercolor="black" width="90%">
              <colgroup>
                <col title="1" width="14.067460317460318%">
                <col title="2" width="85.93253968253968%">
              </colgroup>
              <tbody class="tbody">
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">==</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">égalité des valeurs
(ne pas employer l’opérateur d’affectation =)</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">!=</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <div class="tableau_texte">différence des valeurs (équivaut
au signe mathématique <img class="inlineobject" alt="images/icdifferent.png" src="../download/b844323e-b2d6-4ead-a5c6-57dbf2815b15/images\icdifferent.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAABKTGl2cmVzIGdyYXR1aXRzIGNvZGVyQHR1eGZhbWlseS5vcmcgLSA5OTRjYzFjMS02YjIwLTQ2YTUtODAxNC02YjU3ODNkYjU5MTB%2b7H31jfXQiAsA">)</div>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">&lt;</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">inférieur à</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">&gt;</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">supérieur à </p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">&lt;=</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">inférieur ou égal</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">&gt;=</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">supérieur ou égal</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p class="defaut">Pour améliorer la lisibilité,
il est recommandé d’utiliser des parenthèses pour éclaircir
un prédicat faisant intervenir plusieurs opérateurs.</p>
          <p><span class="bridgehead_niv4">Opérateurs <var style="display:none"> Opérateur:arithmétique</var>arithmétiques</span></p>
          <p class="defaut">Il s’agit bien entendu des quatre opérations
de base - addition, soustraction, multiplication, division - applicables à tout
type numérique, entier ou non. Les entiers connaissent
en plus le reste de la division entière, que l’on appelle parfois
modulo.</p>
          <div class="table">
            <table class="informaltable" style="max-width:90%" align="left" border="1" bordercolor="black" width="90%">
              <colgroup>
                <col title="1" width="14.067460317460318%">
                <col title="2" width="85.93253968253968%">
              </colgroup>
              <tbody class="tbody">
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">++</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">addition</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">-</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">soustraction</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">*</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">multiplication</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">/</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">division</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">%</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">modulo</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p class="defaut">Là encore, ne pas hésiter à ajouter
des parenthèses pour améliorer la lisibilité, même
si certains opérateurs ont une préséance
plus importante que d’autres (* sur +, par exemple).</p>
          <p><span class="bridgehead_niv4"><var style="display:none"> Opérateur:logique</var>Opérateurs logiques</span></p>
          <p class="defaut">Il faut faire attention à ne pas
les confondre avec les opérateurs booléens. Les opérateurs
logiques travaillent au niveau du bit.</p>
          <div class="table">
            <table class="informaltable" style="max-width:90%" align="left" border="1" bordercolor="black" width="90%">
              <colgroup>
                <col title="1" width="14.067460317460318%">
                <col title="2" width="85.93253968253968%">
              </colgroup>
              <tbody class="tbody">
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">~</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">Complément à 1 (non
logique)</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">|</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">ou logique</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">&amp;</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">et logique</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">ˆˆ</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">ou exclusif</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">&lt;&lt;</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">décalage à gauche,
n bits</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">&gt;&gt;</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">décalage à droite,
n bits</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p class="defaut">À chaque fonction logique correspond
une table de vérité, nous commençons avec
le "non logique" :</p>
          <div class="table">
            <table class="informaltable" style="max-width:90%" align="left" border="1" bordercolor="black" width="90%">
              <colgroup>
                <col title="1" width="27.32043292882912%">
                <col title="2" width="72.67956707117086%">
              </colgroup>
              <tbody class="tbody">
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">b</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">~b</span></p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">0</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">1</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">1</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">0</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p class="defaut">Découvrons à présent
le "ou logique" :</p>
          <div class="table">
            <table class="informaltable" style="max-width:90%" align="left" border="1" bordercolor="black" width="90%">
              <colgroup>
                <col title="1" width="27.775925308436143%">
                <col title="2" width="32.37745915305102%">
                <col title="3" width="39.84661553851284%">
              </colgroup>
              <tbody class="tbody">
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">b1</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">b2</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">b1 | b2</span></p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">0</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">0</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">0</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">0</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">1</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">1</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">1</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">0</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">1</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">1</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">1</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">1</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p class="defaut">Voici maintenant le "et logique" :</p>
          <div class="table">
            <table class="informaltable" style="max-width:90%" align="left" border="1" bordercolor="black" width="90%">
              <colgroup>
                <col title="1" width="27.683615819209038%">
                <col title="2" width="32.26985709538053%">
                <col title="3" width="40.04652708541044%">
              </colgroup>
              <tbody class="tbody">
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">b1</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">b2</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">b1 &amp; b2</span></p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">0</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">0</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">0</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">0</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">1</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">0</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">1</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">0</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">0</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">1</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">1</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">1</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p class="defaut">Puis finalement le "ou exclusif"</p>
          <div class="table">
            <table class="informaltable" style="max-width:90%" align="left" border="1" bordercolor="black" width="90%">
              <colgroup>
                <col title="1" width="27.591917853593902%">
                <col title="2" width="32.162967870155676%">
                <col title="3" width="40.24511427625042%">
              </colgroup>
              <tbody class="tbody">
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">b1</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">b2</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">b1 ˆ b2</span></p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">0</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">0</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">0</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">0</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">1</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">1</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">1</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">0</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">1</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">1</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">1</p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">0</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p class="defaut">Pour comprendre les opérateurs de
décalage, un schéma sera plus explicatif&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata" alt="images/02ppn01.png" src="../download/b844323e-b2d6-4ead-a5c6-57dbf2815b15/images\02ppn01.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAABKTGl2cmVzIGdyYXR1aXRzIGNvZGVyQHR1eGZhbWlseS5vcmcgLSA5OTRjYzFjMS02YjIwLTQ2YTUtODAxNC02YjU3ODNkYjU5MTB%2b7H31jfXQiAsA"></div>
          </div>
          <p class="defaut">Le programme correspondant ressemble à ce
qui suit : </p>
          <pre class="programlisting">int main(int argc, _TCHAR* argv[])&nbsp;
{&nbsp;
 &nbsp;char c = 0x2D;&nbsp;
 &nbsp;printf("%x\n",c); &nbsp; &nbsp;// 2D&nbsp;
&nbsp;
 &nbsp;char c1 = c &lt;&lt; 1;&nbsp;
 &nbsp;printf("%x\n",c1); &nbsp; &nbsp;// 5A&nbsp;
&nbsp;
 &nbsp;char c2 = c1 &gt;&gt; 2;&nbsp;
 &nbsp;printf("%x\n",c2); &nbsp; &nbsp;// 16&nbsp;
 &nbsp;return 0;&nbsp;
}
</pre>
          <p class="defaut">Il est à remarquer que le décalage
vers la gauche multiple la quantité par 2, alors que le
décalage à droite divise la quantité par
2. Si le décalage a lieu sur plusieurs bits, la quantité est
modifiée dans un facteur de 2 puissance le nombre de bits
décalés.</p>
          <p class="defaut">Vérifions ceci dans l’exemple donné :
5A = 5x16 + 10 = 90 et 2D = 2x16 + 13 = 45.
Et aussi, 16 = 1x16 + 6 = 22, ce qui
est bien le quart de 90, en arithmétique entière.</p>
          <p class="defaut">Les opérateurs logiques sont particulièrement
utiles lorsque l’on structure un entier (ou un octet), ou bien lorsque
l’on traite un flux binaire. Les bibliothèques de connexion
au réseau en ont également besoin.</p>
          <p class="defaut">Ils sont beaucoup utilisés pour réaliser
des masques de bits, afin de lire telle ou telle partie d’une valeur
entière :</p>
          <pre class="programlisting">int x = 0xCB723E21;&nbsp;
c = (x &amp; 0x00FF0000) &gt;&gt; 16;&nbsp;
printf("%x\n", c); &nbsp;// affiche 72
</pre>
          <p class="defaut">Pour comprendre l’exécution de ce
programme, suivons les calculs sur un dessin&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata" alt="images/02ppn02.png" src="../download/b844323e-b2d6-4ead-a5c6-57dbf2815b15/images\02ppn02.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAABKTGl2cmVzIGdyYXR1aXRzIGNvZGVyQHR1eGZhbWlseS5vcmcgLSA5OTRjYzFjMS02YjIwLTQ2YTUtODAxNC02YjU3ODNkYjU5MTB%2b7H31jfXQiAsA"></div>
          </div>
          <p class="defaut">Évidemment, les 24 bits de poids
fort sont perdus lors de l’affectation de la variable&nbsp;c,
de type char, donc large de 8 bits. Mais on sait aussi que ces 24
bits sont nuls.</p>
          <p><span class="bridgehead_niv4"><var style="display:none"> Opérateur:booléen</var>Opérateurs booléens</span></p>
          <p class="defaut">Les opérateurs booléens
ressemblent aux opérateurs logiques si ce n’est qu’ils fonctionnent
sur des valeurs de booléens et non sur des bits. Bien entendu,
ils reprennent les mêmes tables de vérité mais
le concepteur du langage C a dû introduire des notations
spéciales pour distinguer les deux domaines. On se souvient
en effet que le langage C assimile les entiers (formés
de bits) et les booléens. Le langage C++ a
conservé cette approche pour des raisons de compatibilité.</p>
          <div class="table">
            <table class="informaltable" style="max-width:90%" width="90%">
              <colgroup>
                <col title="1" width="14.067460317460318%">
                <col title="2" width="85.93253968253968%">
              </colgroup>
              <tbody class="tbody">
                <tr class="RowBody">
                  <td class="entry noBorder " style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier_gras">!</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">négation booléenne</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry noBorder " style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier_gras">&amp;&amp;</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">et booléen</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry noBorder " style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier_gras">||</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">ou booléen</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p class="defaut">Il faut remarquer la disparition du ou exclusif,
que l’on peut construire à partir des autres opérateurs
:</p>
          <pre class="programlisting">Xor(p,q) = (p || q) &amp;&amp; ! ( p &amp;&amp; q)
</pre>
          <p class="defaut">Notez également le changement de
notation pour la négation. Le tilde, au lieu d’être
doublé, se transforme en point d’exclamation.</p>
          <p class="defaut">Pour mettre en œuvre ces opérateurs,
on peut soit faire intervenir un booléen, soit employer
le résultat de l’évaluation d’un opérateur
de comparaison&nbsp;:</p>
          <pre class="programlisting">bool p,q;&nbsp;
int x, y;&nbsp;
...&nbsp;
p = q &amp;&amp; (x&lt;y) ;
</pre>
          <p class="defaut">Comme toujours, les parenthèses sont
appréciables pour améliorer la lisibilité. On
peut aussi travailler sur la mise en page pour faciliter la mise
au point d’un prédicat un peu long :</p>
          <pre class="programlisting">if((x &lt; 3 ) &amp;&amp; f(34,2*p)&lt;fgetc(fi) || ! (k %2==0))&nbsp;
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...
</pre>
          <p class="defaut">devrait s’écrire :</p>
          <pre class="programlisting">if((x &lt; 3 ) &amp;&amp; &nbsp;
 &nbsp; f(34,2*p)&lt;fgetc(fi) ||&nbsp;
 &nbsp; ! (k %2==0))
</pre>
          <p><span class="bridgehead_niv4">Les <var style="display:none"> Opérateur:d’incrémentation</var>opérateurs d’incrémentation</span></p>
          <p class="defaut">Ces opérateurs nous viennent directement
de l’assembleur du microprocesseur équipant le PDP-11.
En tant que tels, il s’agit juste d’une notation commode pour augmenter
ou diminuer d’une unité une variable. Mais ils peuvent devenir
très efficaces avec certains processeurs CISC, pour peu
que le mode d’adressage "relatif indexé" soit disponible.</p>
          <p class="defaut">Pour l’heure, nous nous concentrons sur la
syntaxe :</p>
          <div class="table">
            <table class="informaltable" style="max-width:90%" width="90%">
              <colgroup>
                <col title="1" width="14.067460317460318%">
                <col title="2" width="85.93253968253968%">
              </colgroup>
              <tbody class="tbody">
                <tr class="RowBody">
                  <td class="entry noBorder " style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">var</span><span class="courier_gras_11">++</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">Évalue la valeur de la variable
puis augmente la variable d’une unité.</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry noBorder " style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">var</span><span class="courier_gras">--</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">Évalue la valeur de la variable
puis diminue la variable d’une unité.</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry noBorder " style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier_gras_11">--</span><span class="courier11">var</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">Diminue la valeur de la variable puis évalue
sa nouvelle valeur.</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry noBorder " style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier_gras">++</span><span class="courier11">var</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">Augmente la valeur de la variable puis évalue
sa nouvelle valeur.</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p class="defaut">Dans un certain nombre de situations, les
notations préfixées et postfixées donneront
le même résultat :</p>
          <pre class="programlisting">int x = 3;&nbsp;
++x; &nbsp; &nbsp;// ici x++ est tout à fait équivalent&nbsp;
printf("x=%d\n",x); &nbsp;// affiche x=3
</pre>
          <p class="defaut">Dans d’autres cas, l’ordre est très
important :</p>
          <pre class="programlisting">int x=1,y=2;&nbsp;
y=(++x); &nbsp;// x=2, y=2&nbsp;
y=(x++); &nbsp;// x=3, y=2&nbsp;
printf("x=%d, y=%d",x,y); &nbsp;// x=3, y=2
</pre>
        </div>
      </div>
      <div class="sect2">
        <h2 class="title">3. <var style="display:none"> Instructions:de boucle</var>Instructions de boucle</h2>
        <p class="defaut">Les instructions de boucle définissent
des instructions qui sont exécutées plusieurs
fois. Le nombre d’exécutions - que l’on appelle
itérations - est prévu par une condition.</p>
        <p class="defaut">Pour choisir le type de boucle approprié,
il faut toujours se laisser guider par la nécessité algorithmique.
Si l’on connaît à l’avance le nombre d’itérations,
c’est une boucle <span class="courier_gras">for</span>. Dans les
autres cas, c’est une boucle <span class="courier_gras">while</span> (ou <span class="courier_gras">do</span>).</p>
        <div class="sect3">
          <h3 class="title">a. La boucle <var style="display:none"> for</var>for</h3>
          <p class="defaut">Cette instruction est un peu une curiosité.
Elle implémente la structure de contrôle de flot
d’exécution <span class="italic">pour</span> définie
par l’algorithmie impérative, mais il s’agit en fait d’une
instruction <span class="courier_gras">while</span> déguisée.</p>
          <pre class="programlisting">for(initialisation ; prédicat ; incrément)&nbsp;
 &nbsp;instruction
</pre>
          <p class="defaut">L’initialisation sert généralement à affecter
des variables. Le prédicat est le plus souvent basé sur
un opérateur de comparaison tel que <span class="courier11">&lt;</span>.
L’incrément sert à augmenter une variable discrète.</p>
          <p class="defaut">Prenons l’exemple d’une boucle <span class="courier_gras">for</span> prévue pour exécuter
un certain nombre d’itérations :</p>
          <pre class="programlisting">for(int i=1; i&lt;=10; i++)&nbsp;
 &nbsp; &nbsp;printf("i=%d\n",i);
</pre>
          <p class="defaut">Nous aurions pu écrire cela à l’aide
d’une boucle <span class="courier_gras"><var style="display:none"> while</var>while</span> :</p>
          <pre class="programlisting">int i=1;&nbsp;
while(i&lt;=10)&nbsp;
{&nbsp;
 &nbsp;printf("i=%d\n",i);&nbsp;
 &nbsp;i++;&nbsp;
}
</pre>
          <p class="defaut">Toutefois, l’écriture <span class="courier_gras">for</span> est plus concise.</p>
          <p class="defaut">Les programmeurs C et C++ ont
l’habitude de faire commencer i à 0, ce qui change l’expression
du test :</p>
          <pre class="programlisting">for(i=0; i&lt;10; i++)&nbsp;
 &nbsp; &nbsp;...
</pre>
          <p class="defaut">Si l’on compte bien, il y a toujours 10 itérations.
Nous verrons par la suite que les tableaux sont indexés à partir
de 0 et que cette habitude arrange bien les programmes. Par contre,
si vous traduisez d’un programme Pascal ou Basic en C++,
il faut bien surveiller ces valeurs limites.</p>
          <p class="defaut">Dans la boucle <span class="courier_gras">for</span>,
toutes les parties sont optionnelles, mais les points-virgules sont
toujours là :</p>
          <pre class="programlisting">for( ; &nbsp;; )&nbsp;
 &nbsp; &nbsp;...
</pre>
          <p class="defaut">D’autres instructions, telles que <span class="courier_gras"><var style="display:none"> break</var>break</span>, aident alors à sortir
de la boucle.</p>
        </div>
        <div class="sect3">
          <h3 class="title">b. La boucle <var style="display:none"> while</var>while</h3>
          <p class="defaut">L’instruction <span class="courier_gras">while</span> est à privilégier
lorsque l’on ne connaît pas à l’avance le nombre
d’itérations.</p>
          <pre class="programlisting">while( prédicat )&nbsp;
 &nbsp;instruction
</pre>
          <p class="defaut">Bien que <span class="courier_gras">while</span> fonctionne
parfaitement avec une variable discrète, il n’est pas rare
de trouver des exemples qui ressemblent à cela :</p>
          <pre class="programlisting">while( L != null )&nbsp;
{&nbsp;
 &nbsp;printf("%s",L-&gt;element);&nbsp;
 &nbsp;L=L-&gt;suite;&nbsp;
}
</pre>
          <p class="defaut">Il est à remarquer que l’instruction
associée au <span class="courier_gras">while</span> peut
très bien ne pas être exécutée,
si le prédicat se révèle faux d’emblée.</p>
        </div>
        <div class="sect3">
          <h3 class="title">c. La boucle <var style="display:none"> do</var>do</h3>
          <p class="defaut">Au contraire de la boucle <span class="courier_gras">while</span>, le <span class="courier_gras">do</span> provoque
au moins l’exécution d’une itération, car l’évaluation
du prédicat se fait au terme de cette exécution
:</p>
          <pre class="programlisting">do&nbsp;
 &nbsp;instruction&nbsp;
while ( prédicat ) ;
</pre>
          <p class="defaut">Un exemple d’utilisation de cette boucle consiste à lire
des entrées utilisateur :</p>
          <pre class="programlisting">char c;&nbsp;
do&nbsp;
{&nbsp;
 &nbsp;printf("Confirmer O/N");&nbsp;
 &nbsp;scanf("%d",&amp;c);&nbsp;
} while(c!=’o’ &amp;&amp; c!=’O’ &amp;&amp; c!=’n’ &amp;&amp; c!=’N’);
</pre>
        </div>
        <div class="sect3">
          <h3 class="title">d. Les instructions de débranchement</h3>
          <p class="defaut">Le langage C++ compte trois
instructions de débranchement impératif&nbsp;: <span class="courier_gras"><var style="display:none"> goto</var>goto</span>,&nbsp;<span class="courier_gras"><var style="display:none"> continue</var>continue</span> et <span class="courier_gras"><var style="display:none"> break</var>break</span>.</p>
          <p class="defaut">Seules <span class="courier_gras">break</span> et <span class="courier_gras">continue</span> sont toujours usitées.
L’instruction <span class="courier_gras">goto</span> a depuis&nbsp;longtemps
fait la preuve des complications qu’elle entraîne pour
la maintenance et la relecture des programmes.</p>
          <p class="defaut">L’instruction <span class="courier_gras">break</span> sert à sortir
d’une structure de contrôle, <span class="courier11">switch</span> ou boucle.
L’instruction <span class="courier_gras">continue</span> ne s’applique
qu’aux boucles, elle démarre une nouvelle itération.</p>
          <p class="defaut">Il est toujours possible de construire ses
programmes pour éviter l’emploi de <span class="courier_gras">continue</span> et
de <span class="courier_gras">goto</span>. L’instruction <span class="courier_gras_11">break</span> par contre améliore
la lisibilité du programme.</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata" alt="images/02ppn03.png" src="../download/b844323e-b2d6-4ead-a5c6-57dbf2815b15/images\02ppn03.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAABKTGl2cmVzIGdyYXR1aXRzIGNvZGVyQHR1eGZhbWlseS5vcmcgLSA5OTRjYzFjMS02YjIwLTQ2YTUtODAxNC02YjU3ODNkYjU5MTB%2b7H31jfXQiAsA"></div>
          </div>
          <p class="defaut">Il n’est pas rare de combiner ces instructions
avec des tests (<span class="courier11">if</span>), mais cela n’est pas
une nécessité imposée par la syntaxe.</p>
        </div>
      </div>
      <div class="sect2">
        <h2 class="title">4. <var style="display:none"> Tableaux</var>Tableaux</h2>
        <p class="defaut">Les tableaux constituent, tout comme les variables,
une structure très importante pour les algorithmes. Un
tableau est un ensemble de valeurs d’un type déterminé.
On accède à chaque valeur en communiquant au tableau
un numéro&nbsp;que l’on appelle index. En C++,
les index débutent à 0 et croissent jusqu’à N-1,
où N est la taille du tableau, c’est-à-dire le
nombre d’éléments qu’il contient.</p>
        <p class="defaut">Le type du tableau - en fait le type
des éléments qu’il contient - est quelconque
: valeur scalaire, objet, pointeur... Voici deux exemples de tableaux
:</p>
        <pre class="programlisting">double coord[2]; &nbsp;// un tableau de deux double coord[0] &nbsp;
et coord[1]&nbsp;
char* dico[10000]; /* un tableau de 10000 pointeurs dico[0] à dico[9999] */
</pre>
        <p class="defaut">Il est également possible de définir
des tableaux multidimensionnels :</p>
        <pre class="programlisting">double matrice[3][3]; &nbsp;// une matrice, 2 dimensions
</pre>
        <p class="defaut">Pour initialiser un tableau, on peut accéder à chacun
de ses éléments :</p>
        <pre class="programlisting">coord[0]=10;&nbsp;
coord[1]=15;
</pre>
        <p class="defaut">Il est également possible d’initialiser
le tableau en extension, c’est-à-dire en fournissant ses
valeurs au moment de la déclaration :</p>
        <pre class="programlisting">char separateurs[] = { ’ ’,’*’,’-’ };
</pre>
        <p class="defaut">Pour l’initialisation des tableaux de char,
les littérales de chaînes rendent bien des services.
L’écriture suivante :</p>
        <pre class="programlisting">char chaine[]="Bonjour";
</pre>
        <p class="defaut">est plus commode à employer que :</p>
        <pre class="programlisting">char chaine[]={’B’,’o’,’n’,’j’,’o’,’u’,’r’};
</pre>
        <p class="defaut">Voici maintenant l’exemple d’une recherche
de la plus petite valeur dans un tableau de type double :</p>
        <pre class="programlisting">double m; &nbsp;// valeur mini&nbsp;
double tab[] = {-3, 8.2, 5, 57, -11, 1.4 };&nbsp;
&nbsp;
int i;&nbsp;
m=tab[0];&nbsp;
&nbsp;
for(i=0; i&lt;6; i++) &nbsp;// 6 valeurs dans le tableau&nbsp;
 &nbsp;if(tab[i]&lt;m)&nbsp;
 &nbsp; &nbsp;m=tab[i];&nbsp;
&nbsp;
printf("La plus petite valeur est %f",m);
</pre>
        <p class="defaut">La syntaxe de déclaration d’un tableau
repose sur l’emploi des crochets <span class="courier11">[</span> et <span class="courier11">]</span>. Nous verrons un peu plus
loin que les pointeurs et les tableaux dégagent une certaine
similitude.</p>
        <p class="defaut">Les tableaux déclarés avec
la syntaxe <span class="courier11">[</span><span class="courier11">]</span> sont alloués dans
la portée courante&nbsp;; s’il s’agit d’une variable
locale à une fonction ou d’une méthode, ils sont
alloués sur la pile. À l’extérieur ils
peuvent être alloués au niveau du tas (heap) global ou
du segment de l’objet qui les porte.</p>
      </div>
      <div class="sect2">
        <h2 class="title">5. <var style="display:none"> Fonction</var>Fonctions et <var style="display:none"> Prototypes</var>prototypes</h2>
        <p class="defaut">Pour appréhender convenablement la
programmation orientée objet, il est nécessaire&nbsp;de
bien maîtriser la programmation fonctionnelle. Une fonction
est un ensemble d’instructions - et parfois aussi de variables
locales - auquel on a donné un nom. Cette fonction
admet des paramètres et généralement évalue une
valeur en retour.</p>
        <p class="defaut">Une fonction est donc modélisée
par une boîte avec des entrées et une sortie :</p>
        <div class="image">
          <div class="mediaobject"><img class="imagedata" alt="images/02ppn04.png" src="../download/b844323e-b2d6-4ead-a5c6-57dbf2815b15/images\02ppn04.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAABKTGl2cmVzIGdyYXR1aXRzIGNvZGVyQHR1eGZhbWlseS5vcmcgLSA5OTRjYzFjMS02YjIwLTQ2YTUtODAxNC02YjU3ODNkYjU5MTB%2b7H31jfXQiAsA"></div>
        </div>
        <p class="defaut">La signature de la fonction définit
son nom, ses paramètres d’entrée et sa sortie&nbsp;:</p>
        <pre class="programlisting">int somme(int a,int b)
</pre>
        <p class="defaut">Cette séquence précise que
la fonction <span class="courier11">somme()</span> reçoit
deux paramètres de type entier <span class="courier11">a</span> et <span class="courier11">b</span> (entrée) et qu’elle retourne
un entier. Peu importe pour l’instant comment s’exécute
la fonction, c’est-à-dire comment la somme est déterminée.</p>
        <div class="sect3">
          <h3 class="title">a. <var style="display:none"> Déclaration:d’une fonction</var>Déclaration d’une fonction</h3>
          <p class="defaut">En C++, il faut déclarer
une fonction avant de l’utiliser. Deux moyens sont prévus à cet
effet : la définition complète et le prototype.
La définition complète débute par la
signature et se poursuit par la liste des instructions entre deux
accolades :</p>
          <pre class="programlisting">int somme(int a,int b)&nbsp;
{&nbsp;
 &nbsp;return a+b;&nbsp;
}
</pre>
          <p class="defaut">Dans l’approche par prototype, on termine
la déclaration par un point-virgule.</p>
          <pre class="programlisting">int somme(int a,int b) ;
</pre>
          <p class="defaut">La signature et le corps de la fonction (donc
la définition complète) peuvent ainsi figurer
dans un autre fichier source d’extension <span class="courier11">.cpp</span>.
Le compilateur n’a pas besoin d’eux pour compiler, car le prototype
le renseigne déjà sur la liste des paramètres
et le type de retour. Au moment de l’édition des liens,
"tous les morceaux sont recollés".</p>
          <p class="defaut">Il n’est pas rare de regrouper tous les prototypes
dans un fichier d’en-tête <span class="courier11">.h</span>, et
de fournir l’implémentation dans un fichier <span class="courier11">.cpp</span>, ou bien sous forme d’une librairie
statique <span class="courier11">.lib</span>.</p>
        </div>
        <div class="sect3">
          <h3 class="title">b. Fonctions et <var style="display:none"> Procédures</var>procédures</h3>
          <p class="defaut">La même syntaxe est utilisée
pour décrire ces deux éléments, alors
que des langages tels que Basic (<span class="courier11">Function/Sub</span>)
ou Pascal (<span class="courier11">Function/Procedure</span>) les
distinguent. En C++, comme en C, on emploie le
type de retour <span class="courier_gras"><var style="display:none"> void</var>void</span>, terme emprunté à la
langue anglaise et qui signifie vide, vacant. Ce type indique&nbsp;qu’une
fonction ne renvoie rien (il s’agit d’une procédure) ou
bien que l’on n’a pas encore d’information sur le type finalement
employé (cas des pointeurs&nbsp;<span class="courier_gras"><var style="display:none"> void*</var>void*</span>).</p>
          <p class="defaut">Le corps d’une fonction contient un certain
nombre d’instructions <span class="courier_gras"><var style="display:none"> return</var>return</span> qui
stoppent son exécution et retournent une valeur d’un type
conforme à celui&nbsp;de la fonction :</p>
          <div class="table">
            <table class="informaltable" style="max-width:90%" align="left" border="1" bordercolor="black" width="90%">
              <colgroup>
                <col title="1" width="33.59126984126984%">
                <col title="2" width="32.817460317460316%">
                <col title="3" width="33.59126984126984%">
              </colgroup>
              <thead class="thead">
                <tr class="RowHead">
                  <td class="entry" style="text-align:center;vertical-align:top;">
                    <p class="tableau_titre">Type de fonction</p>
                  </td>
                  <td class="entry" style="text-align:center;vertical-align:top;">
                    <p class="tableau_titre">Type de retour</p>
                  </td>
                  <td class="entry" style="text-align:center;vertical-align:top;">
                    <p class="tableau_titre">Exemple</p>
                  </td>
                </tr>
              </thead>
              <tbody class="tbody">
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">void f(...)</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">-</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">return;</span></p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">int f(...)</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">int</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">return 2;</span></p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">bool f(...)</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">bool</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">return (x==2);</span></p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">char* f(...)</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">char*</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">return "bonjour";</span></p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p class="defaut">Pour une procédure, il est possible
d’omettre l’instruction <span class="courier_gras">return</span>.
L’exécution prend fin après la dernière
instruction, celle qui précède l’accolade fermante.
Pour une fonction, il est nécessaire de renvoyer une valeur
conforme au type annoncé.</p>
          <p class="defaut">Par ailleurs, une fonction (ou une procédure)
peut contenir plusieurs instructions <span class="courier_gras">return</span>,
ainsi que l’explicite l’exemple qui suit :</p>
          <pre class="programlisting">enum age { enfant, adolescent, adulte };&nbsp;
&nbsp;
age categoriser(int age)&nbsp;
{&nbsp;
 &nbsp;if(age&lt;13)&nbsp;
 &nbsp; &nbsp;return enfant; &nbsp;// on s’en va&nbsp;
 &nbsp;&nbsp;
 &nbsp;// continue sur age&gt;=13&nbsp;
 &nbsp;if(age&lt;18)&nbsp;
 &nbsp; &nbsp;return adolescent; // on s’en va&nbsp;
&nbsp;
 &nbsp;// continue sur age&gt;=18&nbsp;
 &nbsp;return adulte; &nbsp; &nbsp;// on s’en va&nbsp;
}&nbsp;
&nbsp;
int main(int argc, char* argv[])&nbsp;
{&nbsp;
 &nbsp;int old;&nbsp;
 &nbsp;scanf("%d",&amp;old); &nbsp;// lire un entier depuis le clavier&nbsp;
&nbsp;
 &nbsp;age a; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
 &nbsp;a=categoriser(old); // déterminer la tranche d’âge&nbsp;
&nbsp;
 &nbsp;printf("age=%d",a); &nbsp;// afficher les résultats&nbsp;
 &nbsp;return 0;&nbsp;
}
</pre>
        </div>
        <div class="sect3">
          <h3 class="title">c. <var style="display:none"> Appel:des fonctions</var>Appel des fonctions</h3>
          <p class="defaut">Pour appeler une fonction depuis une autre
fonction, on écrit son nom suivi de parenthèses.
Si la fonction admet des paramètres, leurs valeurs sont
passées dans l’ordre, entre les parenthèses.</p>
          <p class="defaut">Si la fonction retourne une valeur, celle-ci
peut être affectée dans une variable, servir directement
dans une expression ou bien être ignorée :</p>
          <pre class="programlisting">int x;&nbsp;
x=somme(3,b);&nbsp;// additionne 3 et b&nbsp;
y=10+somme(5,7);&nbsp;// le résultat de la fonction est additionné à 10&nbsp;
somme(1,2); &nbsp; &nbsp;// résultat perdu
</pre>
          <p class="defaut">Il est important de ne pas se poser trop de
questions quant au fonctionnement interne d’une fonction à laquelle
on fait appel : elle prend des paramètres et retourne une
valeur. C’est suffisant pour l’appeler. Cette stratégie
rend de grands services lors de la mise au point de fonctions récursives.
Il s’agit de fonctions qui se rappellent elles-mêmes jusqu’à obtention
d’un résultat déterminé.</p>
        </div>
        <div class="sect3">
          <h3 class="title">d. Gestion des <var style="display:none"> Variables locales</var>variables locales</h3>
          <p class="defaut">Lorsqu’une fonction est appelée,
elle construit un environnement local dans la pile. Cet environnement
contient les valeurs des paramètres, puis les variables locales.
Dans le corps de la fonction, paramètres et variables locales
ont la même portée. L’instruction return provoque
la destruction de cet environnement, et si la fonction retourne
une valeur, cette valeur est laissée sur la pile à l’attention
de la fonction appelante.</p>
          <p class="defaut">Nous en déduisons que les variables
locales perdent leur contenu à l’issue de l’exécution
d’une fonction. Le langage C a proposé un mot clé spécial,
static, qui rend persistantes les valeurs des variables locales.
S’agissant d’une curiosité qui n’existe pas dans d’autres
langages que le C++, cette forme est à utiliser le
moins possible.</p>
          <p class="defaut">Il n’y a de toute façon pas de correspondance
algorithmique. Donnons toutefois un exemple pour illustrer sa syntaxe
:</p>
          <pre class="programlisting">void dernier_appel()&nbsp;
{&nbsp;
static int heure;&nbsp;
 &nbsp;printf("time stamp du dernier appel : %d",heure);&nbsp;
 &nbsp;heure=time();&nbsp;
}
</pre>
          <p class="defaut">Quoi qu’il en soit, la création puis
la destruction d’un environnement local est un mécanisme
normal. Sans lui, nous aurions du mal à écrire
des fonctions récursives,&nbsp;fonctions qui permettent
de traiter avec beaucoup d’élégance des problèmes
qui peuvent être complexes à programmer dans des
versions itératives.&nbsp;</p>
        </div>
        <div class="sect3">
          <h3 class="title">e. Définir des <var style="display:none"> Fonction:homonyme</var>fonctions homonymes (<var style="display:none"> Polymorphisme</var>polymorphisme)</h3>
          <p class="defaut">Des fonctions qui portent le même
nom ? On peut en conclure qu’elles remplissent le même
rôle. Créer plusieurs versions d’une même
fonction, voilà leur raison d’être. C’est leur
signature, c’est-à-dire la qualité et la quantité de
leurs arguments, qui les distinguera.</p>
          <p class="defaut">On peut ainsi créer deux versions
de la fonction somme : une première qui prend deux nombres,
une deuxième qui en prend trois.</p>
          <pre class="programlisting">int somme(int a,int b)&nbsp;
{&nbsp;
 &nbsp;return a+b;&nbsp;
}&nbsp;
int somme(int a,int b,int c)&nbsp;
{&nbsp;
 &nbsp;return a+b+c;&nbsp;
}
</pre>
          <p class="defaut">À l’appel de la fonction somme, le
compilateur choisit la forme qui lui paraît convenir le
mieux. S’il n’en trouve pas, il génère une erreur.</p>
          <pre class="programlisting">int p=somme(3,2); &nbsp;// utilise la première forme&nbsp;
int q=somme(4,5,6); // utilise la seconde forme
</pre>
          <p class="defaut">Attention toutefois, le compilateur ne peut
pas toujours distinguer la version à utiliser. Si nous
ajoutons une troisième version utilisant deux nombres de type <span class="courier11">short</span> :</p>
          <pre class="programlisting">int somme(short a,short b)&nbsp;
{&nbsp;
 &nbsp;return a+b;&nbsp;
}
</pre>
          <p class="defaut">L’appel d’une version somme recevant 10 et
11 doit faire hésiter le compilateur. Ces littérales
d’entier sont aussi bien des int que des short. Certains compilateurs
soulèvent un avertissement (warning), d’autres ignorent
ce fait. On peut alors utiliser un opérateur de transtypage
par coercition pour indiquer au compilateur quelle forme utiliser
:</p>
          <pre class="programlisting">somme((short) 3,(short) 4); // utilise la forme avec des short
</pre>
          <p class="defaut">On désigne parfois le polymorphisme
de fonction (l’existence sous plusieurs formes) sous le nom de surcharge.
Quoi qu’il en soit, cette notion est totalement indépendante
de la programmation orientée objet qui n’a pas besoin d’elle
pour exister.</p>
        </div>
        <div class="sect3">
          <h3 class="title">f. <var style="display:none"> Fonction:à nombre variable d’arguments</var>Fonctions à nombre variable d’arguments</h3>
          <p class="defaut">Nous avons déjà rencontré une
fonction à nombre variable d’arguments : <span class="courier_gras"><var style="display:none"> printf</var>printf</span>. Cette fonction admet comme
premier paramètre une chaîne de formatage, puis
une série de valeurs destinées à être
présentées par le biais de ces formateurs :</p>
          <pre class="programlisting">printf("%s %d %x","bonjour",34,32);
</pre>
          <p class="defaut">Dans cet exemple, <span class="courier11">printf</span> admet
quatre arguments. Le premier recense trois formateurs (<span class="courier11">%s</span>, <span class="courier11">%d</span> et <span class="courier11">%x</span>), il est suivi par trois
valeurs conformes au type indiqué&nbsp;par les formateurs
:</p>
          <div class="table">
            <table class="informaltable" style="max-width:90%" width="90%">
              <colgroup>
                <col title="1" width="19.491525423728813%">
                <col title="2" width="80.5084745762712%">
              </colgroup>
              <tbody class="tbody">
                <tr class="RowBody">
                  <td class="entry noBorder " style="text-align:justify;vertical-align:top;"><var style="display:none"> %s</var><p class="tableau_texte"><span class="courier11">%s</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">chaîne (char*)</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry noBorder " style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11"><var style="display:none"> %d</var>%d</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">entier (décimal)</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry noBorder " style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11"><var style="display:none"> %x</var>%x</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">entier (hexadécimal)</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p class="defaut">Vous pouvez définir vos propres fonctions à nombre
variable d’arguments. Des macros spéciales permettent de
traiter la liste des arguments transmise à votre fonction.</p>
          <pre class="programlisting">#include &lt;iostream.h&gt;&nbsp;
#include &lt;stdarg.h&gt;&nbsp;
&nbsp;
int somme(int n, ...)&nbsp;
{&nbsp;
 &nbsp;va_list ap; &nbsp; &nbsp; &nbsp;// liste des paramètres&nbsp;
 &nbsp;va_start(ap,n); &nbsp; &nbsp;// se placer après le dernier argument formel&nbsp;
&nbsp;
 &nbsp;int i,s=0;&nbsp;
 &nbsp;while(n--)&nbsp;
 &nbsp;{&nbsp;
 &nbsp; &nbsp;i=va_arg(ap,int); &nbsp;// récupérer l’argument suivant de type int&nbsp;
 &nbsp; &nbsp;s+=i;&nbsp;
 &nbsp;} &nbsp;
 &nbsp;va_end(ap); &nbsp; &nbsp; &nbsp;// nettoyer la liste des arguments&nbsp;
 &nbsp;return s;&nbsp;
}&nbsp;
&nbsp;
int main(int argc, char* argv[])&nbsp;
{&nbsp;
 &nbsp;cout &lt;&lt; somme(4,1,2,3,4); // affiche le résultat&nbsp;
 &nbsp;return 0;&nbsp;
}
</pre>
          <p class="defaut">Dans cet exemple, la fonction <span class="courier11">somme</span> reçoit au moins un
paramètre, <span class="courier11">n</span>, qui indique&nbsp;le
nombre d’éléments à additionner. Le symbole
spécial <span class="courier11">...</span> dans la signature&nbsp;de
la fonction indique qu’il s’agissait du dernier paramètre
formel, c’est-à-dire du dernier paramètre nommé.
Les autres paramètres - qui peuvent&nbsp;être
omis à l’appel - sont accessibles via la macro <span class="courier11">va_arg()</span>.</p>
        </div>
        <div class="sect3">
          <h3 class="title">g. Donner des <var style="display:none"> Valeurs par défaut aux arguments</var>valeurs par défaut aux arguments</h3>
          <p class="defaut">Cette syntaxe n’a pas de correspondance algorithmique,
mais elle peut guider le programmeur lorsqu’il hésite à fournir
certains paramètres lors de l’appel d’une fonction.</p>
          <p class="defaut">Par exemple, imaginons la fonction suivante
:</p>
          <pre class="programlisting">void printlog(char*message,FILE* f=NULL)&nbsp;
{&nbsp;
if(f==NULL)&nbsp;
 &nbsp;printf(message); // affiche à l’écran&nbsp;
else&nbsp;
 &nbsp;fprintf(f,message); // affiche dans un fichier&nbsp;
}
</pre>
          <p class="defaut">Le programmeur qui utilise notre fonction
printlog comprend que la fourniture du paramètre f n’est
pas obligatoire, puisqu’il a reçu une valeur par défaut.</p>
          <p class="defaut">On peut alors appeler <span class="courier11">printlog()</span> de
deux façons :</p>
          <pre class="programlisting">printlog("démarrage de l’application");&nbsp;
printlog("démarrage de l’application",f_erreur);
</pre>
          <p class="defaut">Dans le premier cas, le message s’affichera à l’écran,
la fonction détectant une valeur <span class="courier_gras"><var style="display:none"> NULL</var>NULL</span> pour
le paramètre <span class="courier11">f</span>. Dans le
second cas, <span class="courier11">f_erreur</span> étant
réputé non nul, le message s’inscrira dans un
fichier préalablement ouvert, représenté par <span class="courier11">f_erreur</span>.</p>
          <p class="defaut">Attention de ne pas provoquer de conflit entre
les versions polymorphes (surchargées) et les versions
de fonctions recevant des valeurs par défaut. La construction
suivante est par exemple illicite :</p>
          <pre class="programlisting">int somme(int a,int b)&nbsp;
{&nbsp;
 &nbsp;return a+b;&nbsp;
}&nbsp;
int somme(int a,int b,int c=0)&nbsp;
{&nbsp;
 &nbsp;return a+b+c;&nbsp;
}
</pre>
          <p class="defaut">À l’appel de la fonction <span class="courier11">somme</span> recevant deux arguments, le
compilateur ne pourra déterminer s’il s’agit de l’omission
du paramètre c ou bien si le programmeur a l’intention
d’utiliser la première forme.</p>
        </div>
        <div class="sect3">
          <h3 class="title">h. <var style="display:none"> Fonction:en ligne</var>Fonctions en ligne</h3>
          <p class="defaut">Les fonctions en ligne offrent un temps d’appel
très court puisque précisément elles
ne provoquent pas de débranchement (go sub). Le code qu’elles
renferment est développé en lieu et place de l’appel.</p>
          <p class="defaut">À l’utilisation, cette caractéristique
n’apparaît pas dans la syntaxe mais cela peut faire croître
la taille du code de manière inopportune si la fonction
est appelée&nbsp;en différents points du programme.</p>
          <pre class="programlisting">inline int somme(int a,int b)&nbsp;
{&nbsp;
 &nbsp; &nbsp;return a+b;&nbsp;
}&nbsp;
&nbsp;
...&nbsp;
x = somme(3,4); // Place le code ici plutôt que d’effectuer 
un débranchement
</pre>
        </div>
        <div class="sect3">
          <h3 class="title">i. <var style="display:none"> Fonction:externe</var>Fonctions externes de type C</h3>
          <p class="defaut">La directive <span class="courier_gras"><var style="display:none"> extern "C"</var>extern
"C"</span> indique au compilateur qu’il doit utiliser une convention
d’appel de type C pour appeler une fonction. Les langages C++ et C
ont des fonctionnements internes proches mais pas complètement identiques,&nbsp;notamment
en ce qui concerne l’appel de fonction. Dans le cas du langage C,
les paramètres sont empilés du dernier au premier,
la fonction s’exécute puis l’appelant restaure la pile
après avoir récupéré la valeur
de retour de la fonction. Dans le cas du langage C++,
l’ordre des paramètres est inverse et c’est l’appelé qui
restaure son cadre de pile.</p>
          <p class="defaut">En conclusion, vous devez préfixer
vos déclarations de fonctions par <span class="courier11">extern "C"</span> si
elles sont issues d’un compilateur C :</p>
          <pre class="programlisting">extern "C" int yylex();
</pre>
        </div>
        <div class="sect3">
          <h3 class="title">j. <var style="display:none"> Fonction:récursive</var>Fonctions récursives</h3>
          <p class="defaut">Il ne s’agit pas d’une spécificité du
langage C++, aucune syntaxe particulière n’est
nécessaire, mais plutôt d’une caractéristique
supportée. Les fonctions C++ ont la possibilité de
se rappeler elles-mêmes. Pour le lecteur qui découvre ce
style de programmation, l’exemple du calcul de la factorielle est
un bon point de départ.</p>
          <p class="defaut">La factorielle (notée en mathématique
!, mais cette notation n’a rien à voir avec l’opérateur
de négation booléenne du C++)
est une "fonction" qui se détermine&nbsp;comme suit
:</p>
          <pre class="programlisting">!1 = 1 = 1&nbsp;
!2 = 2 x 1 = 2&nbsp;
!3 = 3 x 2 x 1 = 6&nbsp;
!4 = 4 x 3 x 2 x 1 = 24&nbsp;
...&nbsp;
!n = n x (n-1) x (n-2) x ... x 1
</pre>
          <p class="defaut">Il est facile de donner une version dite itérative
d’une fonction qui calcule cette factorielle. Le type <span class="courier11">long</span> a été retenu
car la factorielle croit très rapidement et la limite des
deux milliards du type <span class="courier11">int</span> est vite
atteinte.</p>
          <pre class="programlisting">long factorielle(long n)&nbsp;
{&nbsp;
long r=1;&nbsp;
 &nbsp;while(n-- &gt;0)&nbsp;
 &nbsp; &nbsp;r=r*n; &nbsp;// on aurait pu noter aussi r*=n&nbsp;
 &nbsp;return r;&nbsp;
}
</pre>
          <p class="defaut">Cette version fonctionne parfaitement, si
ce n’est qu’en l’absence d’un nom explicite&nbsp;pour la fonction,
on aurait du mal à déterminer si elle calcule
la factorielle&nbsp;ou un autre produit.</p>
          <p class="defaut">En reprenant l’expression générale
de la factorielle, on peut procéder à une réécriture&nbsp;très
simple : </p>
          <pre class="programlisting">!n = n x (n-1) x (n-2) x...x1&nbsp;
= n x !(n-1) 
</pre>
          <p class="defaut">Autrement dit, la factorielle de n est égale à n
multiplié par la factorielle de (n-1), avec comme point
de départ !1=1. </p>
          <p class="defaut">Nous en déduisons une nouvelle version
:</p>
          <pre class="programlisting">long factorielle_r(long n)&nbsp;
{&nbsp;
 &nbsp;if(n==1)&nbsp;
 &nbsp; &nbsp;return 1; &nbsp;// !1=1&nbsp;
 &nbsp;else&nbsp;
 &nbsp; &nbsp;return n*factorielle_r(n-1); // &nbsp;nx !(n-1)&nbsp;
}
</pre>
          <p class="defaut">L’écriture est beaucoup plus simple à comprendre
et à reconnaître. Ceci dit, certains algorithmes
se prêtent bien à ce style de programmation, comme
le parcours de documents XML, alors que d’autres n’en tireront aucun
profit. Par ailleurs, certains algorithmes deviennent vite voraces
en termes d’espace utilisé&nbsp;par la pile. </p>
          <p class="defaut">Le calcul de la suite de Fibonnacci <span class="courier11">fib(n)=fib(n-1)+fib(n-2)</span>,
avec <span class="courier11">fib(1)=fib(2)=1</span>,
plante souvent aux environs de <span class="courier11">fib(50)</span> tant
le nombre de calculs en suspens est élevé.</p>
        </div>
        <div class="sect3">
          <h3 class="title">k. La fonction <var style="display:none"> main()</var>main()</h3>
          <p class="defaut">Tous les programmes C++ exécutables
contiennent une fonction <span class="courier11">main()</span>, appartenant à l’espace
de noms global. Cette fonction peut parfois porter un nom un peu
différent, cela dépend des compilateurs et des éditeurs
de liens. En général, c’est main (principal).</p>
          <p class="defaut">La <var style="display:none"> Fonction:main()</var>fonction <span class="courier11">main()</span> renvoie
en principe un code entier, la convention voulant qu’un code nul
signifie que le programme a fonctionné normalement et qu’un code
non nul indique une erreur dont l’interprétation est laissée
aux soins du programmeur. Avec l’apparition des programmes graphiques
(au détriment des utilitaires en ligne de commande), cette
convention a un peu tendance à s’estomper. Cela dépend
des systèmes d’exploitation. Certains compilateurs acceptent
même une définition <span class="courier11">void</span> pour
main et renvoient un code 0 par défaut.</p>
          <p class="defaut">La fonction <span class="courier11">main()</span> peut
aussi admettre des paramètres destinés à recueillir les
arguments passés sur la ligne de commande :</p>
          <pre class="programlisting">int main(int argc,char* argv[])&nbsp;
{&nbsp;
}
</pre>
          <p class="defaut">Le premier argument, de type entier, se nomme
souvent argc - pour argument count. Il désigne
le nombre d’arguments passés par la ligne de commande.
En principe, il vaut au moins un, le tout premier argument étant
le nom du programme&nbsp;exécutable. Le second argument,
argv - pour argument value - est un tableau de
chaînes. On trouve également comme signature char** ce
qui revient au même (voir la partie sur les pointeurs).
Il est facile de prévoir une petite boucle pour afficher
les paramètres de la ligne de commande : </p>
          <pre class="programlisting">/* affiche.cpp */&nbsp;
int main(int argc,char* argv[])&nbsp;
{&nbsp;
 &nbsp;for(int i=1; i&lt;argc; i++)&nbsp;
 &nbsp; &nbsp;printf("argument n%d = %s\n",i,argv[i]);&nbsp;
}
</pre>
          <p class="defaut">Nous compilons ce programme avec la ligne
suivante : </p>
          <pre class="programlisting">g++ affiche.cpp o affiche
</pre>
          <p class="defaut">Puis nous exécutons le programme&nbsp;:</p>
          <pre class="programlisting">affiche valeur1 valeur2 "salut les amis" 34
</pre>
          <p class="defaut">Le programme produit l’affichage suivant :</p>
          <pre class="programlisting">argument n1 = valeur1&nbsp;
argument n2 = valeur2&nbsp;
argument n3 = "salut les amis"&nbsp;
argument n4 = 34
</pre>
          <p class="defaut">Si certains arguments représentent
des nombres, il faudra les convertir depuis le type chaîne
dans le type voulu à l’aide des fonctions correspondantes,
telles <span class="courier_gras">atoi()</span> - alpha
to integer - ou <span class="courier_gras">atof</span> - alpha
to float.</p>
          <p class="defaut">En résumé, les signatures
suivantes sont possibles pour main() :</p>
          <div class="table">
            <table class="informaltable" style="max-width:90%" align="left" border="1" bordercolor="black" width="90%">
              <colgroup>
                <col title="1" width="44.53264536614409%">
                <col title="2" width="55.467354633855926%">
              </colgroup>
              <tbody class="tbody">
                <tr class="RowBody">
                  <td class="entry" style="text-align:left;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">void main()</span></p>
                  </td>
                  <td class="entry" style="text-align:left;vertical-align:top;">
                    <p class="tableau_texte">En fait int main(), le compilateur transformant
lui-même la fonction et ajoutant un return 0 à la
fin.</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:left;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">int main()</span></p>
                  </td>
                  <td class="entry" style="text-align:left;vertical-align:top;">
                    <p class="tableau_texte">Version habituelle.</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:left;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">int main(int
argc)</span></p>
                  </td>
                  <td class="entry" style="text-align:left;vertical-align:top;">
                    <p class="tableau_texte">Licite mais sans intérêt.</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:left;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">int main(char*argv[]) </span>ou<span class="courier11">int main(char**argv)</span></p>
                  </td>
                  <td class="entry" style="text-align:left;vertical-align:top;">
                    <p class="tableau_texte">Le programmeur doit bien contrôler le&nbsp;nombre
d’arguments passés.</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:left;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">int main(int argc,char*argv[]) </span>ou<span class="courier11">  int main(int argc,char** argv)</span></p>
                  </td>
                  <td class="entry" style="text-align:left;vertical-align:top;">
                    <p class="tableau_texte">Version la plus logique lorsque l’on souhaite&nbsp;recueillir
les arguments de la ligne&nbsp;de commande.</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p class="defaut">Quoi qu’il en soit, cette fonction <span class="courier11">main()</span> est unique dans un programme.
Les programmes qui n’en contiennent pas sont de ce fait destinés à construire
des librairies statiques. Il est courant, pour les librairies dynamiques
(DLL) de posséder&nbsp;une fonction <span class="courier11">libmain()</span> chargée de procéder à des
initialisations.</p>
          <p class="defaut">Enfin, selon les systèmes d’exploitation,
on pourra trouver des signatures un&nbsp;peu différentes.
C’est notamment le cas des applications graphiques Windows.&nbsp;</p>
        </div>
      </div>
      <div class="sect2">
        <h2 class="title">6. Les <var style="display:none"> Pointeur</var>pointeurs</h2>
        <p class="defaut">Les pointeurs et les <var style="display:none"> Références</var>références
sont des outils particulièrement intéressants.
Le langage C ne connaît pas les références,
mais il peut travailler avec les pointeurs&nbsp;en suivant les
règles applicables aux références. Des
langages plus récents, comme Java, ont supprimé les
pointeurs de leur vocabulaire. Non pas parce qu’ils pourraient avoir
mauvaise réputation auprès des programmeurs, mais
parce qu’ils agissent à un niveau plus bas que les références,
ce qui perturbe&nbsp;l’usage d’outils de haut niveau tels que
le ramasse-miettes (garbage collector).</p>
        <p class="defaut">Pointeurs et références
sont des variables qui permettent d’atteindre d’autres variables.
Pour parvenir à ce résultat, le pointeur (ou la
référence) utilise l’adresse de la variable cible,
c’est-à-dire le numéro de la case mémoire
où est rangée la valeur de cette variable. Comme
la mémoire est comptée en octets, et qu’une variable
peut répartir la représentation de sa valeur sur
plusieurs octets,&nbsp;pointeurs et références
sont des variables définies pour travailler avec un type
donné, dans le but de limiter les erreurs d’adressage.</p>
        <div class="sect3">
          <h3 class="title">a. <var style="display:none"> Pointeur:sur des variables</var>Pointeurs sur des variables</h3>
          <p class="defaut">Commençons par étudier la
représentation d’un fragment de la mémoire de l’ordinateur.
Ce fragment contient une variable x de type char, préalablement initialisée à la
valeur 3. Le plus souvent, les adresses s’écrivent en hexadécimal pour
mieux les distinguer des valeurs stockées en mémoire,
mais aussi car les adresses 16 ou 32 bits s’écrivent facilement
dans cette base.</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata" alt="images/02ppn05.png" src="../download/b844323e-b2d6-4ead-a5c6-57dbf2815b15/images\02ppn05.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAABKTGl2cmVzIGdyYXR1aXRzIGNvZGVyQHR1eGZhbWlseS5vcmcgLSA5OTRjYzFjMS02YjIwLTQ2YTUtODAxNC02YjU3ODNkYjU5MTB%2b7H31jfXQiAsA"></div>
          </div>
          <p class="defaut">Pour affecter la valeur 10 à la variable
x, par exemple, nous pouvons utiliser l’extrait de code suivant
:</p>
          <pre class="programlisting">char x=3;&nbsp;
 &nbsp; &nbsp; x=10;
</pre>
          <p class="defaut">Si nous pouvions obtenir l’adresse de la variable <span class="courier11">x</span>, 0x1003 dans notre cas, nous pourrions
modifier cette variable sans utiliser directement x. Pour cela,
nous allons définir un pointeur de type char, noté char*.
Cette variable spéciale, <span class="courier11">p</span>, recevra
l’adresse de la variable <span class="courier11">x</span>, déterminée à l’aide
d’une syntaxe spéciale. Ensuite,&nbsp;nous pourrons
modifier la valeur située à cet emplacement mémoire, même
si la variable <span class="courier11">x</span> n’est plus dans
notre portée. </p>
          <pre class="programlisting">char* p; &nbsp;// déclare un pointeur de type char&nbsp;
&nbsp;
 &nbsp;p=&amp;x; &nbsp;// obtient l’adresse de la variable x&nbsp;
&nbsp;
 &nbsp;printf("p=%x",p); &nbsp;// affiche 1003 en hexa&nbsp;
&nbsp;
 &nbsp;*p=10; &nbsp;// affecte indirectement la variable x
</pre>
          <p class="defaut">Il faut noter l’aspect quelque peu artificiel
de cet exemple. Pour modifier la valeur d’une variable, la syntaxe
habituelle convient très bien et il n’y a pas besoin d’en
changer.</p>
          <p class="defaut">Pour comprendre l’utilité de cette
approche, créons une procédure qui transforme
un caractère minuscule en majuscule :</p>
          <pre class="programlisting">void maj(char c)&nbsp;
{&nbsp;
 &nbsp;printf("avant c=%c\n",c);&nbsp;
 &nbsp;if(c&gt;=’a’ &amp;&amp; c&lt;=’z’)&nbsp;
 &nbsp; &nbsp;c=c-(’a’-’A’);&nbsp;
 &nbsp;printf("après c=%c\n",c);&nbsp;
}&nbsp;
&nbsp;
int main()&nbsp;
{&nbsp;
 &nbsp;char x=’a’;&nbsp;
 &nbsp;maj(x);&nbsp;
 &nbsp;printf("finalement, x=%c\n",x);&nbsp;
 &nbsp;return 0;&nbsp;
}
</pre>
          <p class="defaut">Toutefois, l’exécution de ce programme
ne donne pas les résultats attendus :</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata" alt="images/01RI01.png" src="../download/b844323e-b2d6-4ead-a5c6-57dbf2815b15/images\01RI01.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAABKTGl2cmVzIGdyYXR1aXRzIGNvZGVyQHR1eGZhbWlseS5vcmcgLSA5OTRjYzFjMS02YjIwLTQ2YTUtODAxNC02YjU3ODNkYjU5MTB%2b7H31jfXQiAsA"></div>
          </div>
          <p class="defaut">Que s’est-il passé ? À l’appel
de la fonction <span class="courier11">maj()</span>, nous avons
transmis par l’intermédiaire de la pile une copie de la
variable <span class="courier11">x</span>. Dans la portée
de la fonction <span class="courier11">maj()</span>, cette valeur
s’appelle c. Il s’agit d’un paramètre qui a la durée
de vie d’une variable locale. Tout se passe comme si nous avions écrit&nbsp;:</p>
          <div class="table">
            <table class="informaltable" style="max-width:90%" align="left" border="1" bordercolor="black" width="90%">
              <colgroup>
                <col title="1" width="50%">
                <col title="2" width="50%">
              </colgroup>
              <thead class="thead">
                <tr class="RowHead">
                  <td class="entry" style="text-align:center;vertical-align:top;">
                    <p class="tableau_titre">Fonction maj</p>
                  </td>
                  <td class="entry" style="text-align:center;vertical-align:top;">
                    <p class="tableau_titre">Fonction main</p>
                  </td>
                </tr>
              </thead>
              <tbody class="tbody">
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">
                      </p><pre class="literallayout">char c=x
</pre>
                    <p></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">
                      </p><pre class="literallayout">maj(x)
</pre>
                    <p></p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">
                      </p><pre class="literallayout">printf("avant c=%c\n",c);
if(c&gt;=’a’ &amp;&amp; c&lt;=’z’)
&nbsp;&nbsp;&nbsp;c=c-(’a’-’A’);
printf("après c=%c\n",c);
</pre>
                    <p></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"></p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">
                      </p><pre class="literallayout">printf("finalement, x=%c\n",x);
</pre>
                    <p></p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p class="defaut">On comprend alors que la variable <span class="courier11">x</span> est restée bien tranquille
! C’est sa copie, <span class="courier11">c</span>, qui a été modifiée.</p>
          <p class="defaut">À présent, nous modifions
la fonction <span class="courier11">maj()</span> pour qu’elle reçoive
non une valeur de type char mais un pointeur vers une variable de
type char : </p>
          <pre class="programlisting">void maj(char* c)&nbsp;
{&nbsp;
 &nbsp;printf("avant c=%c\n",*c);&nbsp;
 &nbsp;if(*c&gt;=’a’ &amp;&amp; *c&lt;=’z’)&nbsp;
 &nbsp; &nbsp;*c=*c-(’a’-’A’);&nbsp;
 &nbsp;printf("après c=%c\n",*c);&nbsp;
}&nbsp;
&nbsp;
int main()&nbsp;
{&nbsp;
 &nbsp;char x=’a’;&nbsp;
 &nbsp;maj(&amp;x);&nbsp;
 &nbsp;printf("finalement, x=%c\n",x);&nbsp;
 &nbsp;return 0;&nbsp;
}
</pre>
          <p class="defaut">L’exécution est cette fois-ci conforme à nos
attentes, la variable <span class="courier11">x</span> a bien été modifiée
:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata" alt="images/01RI02.png" src="../download/b844323e-b2d6-4ead-a5c6-57dbf2815b15/images\01RI02.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAABKTGl2cmVzIGdyYXR1aXRzIGNvZGVyQHR1eGZhbWlseS5vcmcgLSA5OTRjYzFjMS02YjIwLTQ2YTUtODAxNC02YjU3ODNkYjU5MTB%2b7H31jfXQiAsA"></div>
          </div>
          <p class="defaut">Il est temps de résumer les notations
relatives aux pointeurs :</p>
          <div class="table">
            <table class="informaltable" style="max-width:90%" align="left" border="1" bordercolor="black" width="90%">
              <colgroup>
                <col title="1" width="14.067460317460318%">
                <col title="2" width="85.93253968253968%">
              </colgroup>
              <tbody class="tbody">
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">char* p</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">déclare p comme pointeur de
type char, c’est-à-dire comme pointeur sur une variable
de type char.</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">&amp;x</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">désigne l’adresse de la variable
x.</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">*p</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">si p est un pointeur, désigne
la valeur pointée par p, donc la valeur située à la
case mémoire indiquée par p.</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p class="defaut">Maintenant que <span class="courier11">maj()</span> admet
un pointeur sur <span class="courier11">char</span>, il n’est plus
possible de l’appeler en lui transmettant une littérale
de caractère :</p>
          <div class="table">
            <table class="informaltable" style="max-width:90%" align="left" border="1" bordercolor="black" width="90%">
              <colgroup>
                <col title="1" width="32.81746031746032%">
                <col title="2" width="18.750000000000003%">
                <col title="3" width="48.43253968253969%">
              </colgroup>
              <thead class="thead">
                <tr class="RowHead">
                  <td class="entry" style="text-align:center;vertical-align:top;">
                    <p class="tableau_titre">Signature</p>
                  </td>
                  <td class="entry" style="text-align:center;vertical-align:top;">
                    <p class="tableau_titre">Appel</p>
                  </td>
                  <td class="entry" style="text-align:center;vertical-align:top;">
                    <p class="tableau_titre">Commentaire</p>
                  </td>
                </tr>
              </thead>
              <tbody class="tbody">
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">void maj(char
c)</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">maj(x)</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">c initialisé à la valeur
de x</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">void maj(char
c)</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">maj(’t’)</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">c initialisé à la valeur
’t’</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">void maj(char* c)</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">maj(&amp;x)</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">c pointeur sur char, désigne
la variable x</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">void maj(char* c)</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">maj(&amp;’t’)</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">erreur, une littérale de char
n’a pas d’adresse</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <div class="sect3"><var style="display:none"> Pointeurs et tableaux</var><h3 class="title">b. Pointeurs et tableaux</h3>
          <p class="defaut">Nous avons vu précédemment
la syntaxe de déclaration d’un pointeur sur une variable.
Ce pointeur sert à atteindre une case mémoire
par l’intermédiaire de la notation * :</p>
          <pre class="programlisting">char* p;&nbsp;
char c;&nbsp;
 &nbsp;p=&amp;c;&nbsp;
 &nbsp;*p=’K’;
</pre>
          <p class="defaut">Imaginons que la cible ne soit plus une variable
c, mais une plage de caractères (autrement dit, un tableau
de char). Nous obtiendrons la représentation mémoire
suivante pour une plage de 5 valeurs débutant à l’adresse
0x1002 :</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata" alt="images/02ppn06.png" src="../download/b844323e-b2d6-4ead-a5c6-57dbf2815b15/images\02ppn06.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAABKTGl2cmVzIGdyYXR1aXRzIGNvZGVyQHR1eGZhbWlseS5vcmcgLSA5OTRjYzFjMS02YjIwLTQ2YTUtODAxNC02YjU3ODNkYjU5MTB%2b7H31jfXQiAsA"></div>
          </div>
          <p class="defaut">Pour déclarer un tableau de 5 char,
nous pouvons utiliser la syntaxe suivante :</p>
          <pre class="programlisting">char tab[]={’S’,’A’,’L’,’U’,’T’ };
</pre>
          <p class="defaut">Le compilateur va ranger ces cinq valeurs
dans une partie de la mémoire. La variable <span class="courier11">tab</span> contiendra en fait l’adresse de
début de cette plage. Autrement dit, <span class="courier11">tab</span> se
comporte comme un pointeur de char, en désignant le premier
de ces char.</p>
          <p class="defaut">Poursuivons notre raisonnement :</p>
          <pre class="programlisting">char* pt=tab;
</pre>
          <p class="defaut">Le pointeur de <span class="courier11">char</span>, <span class="courier11">pt</span>, a reçu l’adresse du tableau,
c’est-à-dire qu’il pointe sur le premier <span class="courier11">char</span>. Nous en déduisons que
les écritures suivantes sont équivalentes :</p>
          <pre class="programlisting">*pt=’S’;&nbsp;
tab[0]=’S’;
</pre>
          <p class="defaut">Maintenant, nous voudrions atteindre la deuxième
case du tableau :</p>
          <pre class="programlisting">tab[1]=’A’;
</pre>
          <p class="defaut">En passant par le pointeur, nous avons trois
moyens d’obtenir le même résultat :</p>
          <div class="table">
            <table class="informaltable" style="max-width:90%" align="left" border="1" bordercolor="black" width="90%">
              <colgroup>
                <col title="1" width="60.94463187140307%">
                <col title="2" width="19.527684064298473%">
                <col title="3" width="19.527684064298473%">
              </colgroup>
              <thead class="thead">
                <tr class="RowHead">
                  <td class="entry" style="text-align:center;vertical-align:top;">
                    <p class="tableau_titre"><var style="display:none"> Déplacement du pointeur</var>Déplacement du pointeur</p>
                  </td>
                  <td class="entry" style="text-align:center;vertical-align:top;">
                    <p class="tableau_titre"><var style="display:none"> Notation tableau</var>Notation  tableau</p>
                  </td>
                  <td class="entry" style="text-align:center;vertical-align:top;"><var style="display:none"> Notation pointeur</var><p class="tableau_titre">Notation pointeur</p>
                  </td>
                </tr>
              </thead>
              <tbody class="tbody">
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">
                      </p><pre class="literallayout">pt++; // désigne la case d’après *pt=’A’;
</pre>
                    <p></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">
                      </p><pre class="literallayout">pt[1]=’A’;
</pre>
                    <p></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">
                      </p><pre class="literallayout">*(pt+1)=’A’;
</pre>
                    <p></p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p class="defaut">La première notation consiste à déplacer
le pointeur. Rappelons-nous qu’il s’agit d’une variable, dont la
valeur entière est une adresse. Incrémenter cette valeur
d’une unité revient à déplacer le pointeur
afin qu’il désigne la case voisine.&nbsp;Ensuite, nous
utilisons la notation habituelle, <span class="courier11">*pt</span>,
pour écrire à cette position de la mémoire.</p>
          <p class="defaut">La deuxième notation, <span class="courier11">pt[1]</span>, pousse encore
la similitude entre pointeur et tableau. Si pt et tab coïncident
sur la première case, la notation à base de crochets&nbsp;<span class="courier11">[ ]</span> doit également
correspondre pour toutes les valeurs du tableau.</p>
          <p class="defaut">Pour expliquer la troisième notation,
commençons par étudier l’expression suivante :</p>
          <pre class="programlisting">*pt=’A’;
</pre>
          <p class="defaut">Puisque <span class="courier11">pt</span> représente
une adresse (la valeur de la variable), il semble logique d’écrire
:</p>
          <pre class="programlisting">*(pt)=’A’;
</pre>
          <p class="defaut">Maintenant, considérant que pt est
un nombre entier, il est possible de lui additionner&nbsp;un
autre entier, la somme des deux représentant une nouvelle adresse
:</p>
          <pre class="programlisting">*(pt+1)=’A’;
</pre>
          <p class="defaut">Si pointeurs et tableaux sont si proches,
pourquoi conserver les deux ? Il faut considérer que le
pointeur est une variable totalement libre, étant affectée avec
l’adresse d’une variable <span class="courier11">&amp;v</span>,
ou bien recevant l’adresse d’un bloc mémoire fraîchement
alloué par l’opérateur <span class="courier11">new</span> ou
par la fonction <span class="courier11">malloc()</span>. Le tableau&nbsp;lui
peut s’initialiser avec des valeurs en extension ou bien avec l’opérateur <span class="courier11">new</span>, mais pas avec la fonction <span class="courier11">malloc()</span>.</p>
          <p class="defaut">Ensuite, les pointeurs sont employés
lorsque l’on a recours à l’arithmétique des pointeurs
; ils sont prévus pour être déplacés
au gré des nécessités de l’algorithme.
Le tableau lui est fixe, et la notation suivante est prohibée
:</p>
          <pre class="programlisting">char tab[]={ 2,3,44 };&nbsp;
tab++; // interdit
</pre>
          <p class="defaut">Enfin, les pointeurs sont utiles à certains
algorithmes seulement. Privilégiez les tableaux chaque
fois que ce sera possible, votre programme sera nettement plus portable.
D’autant que les références constituent une bonne
alternative aux pointeurs. Mais à l’époque de
la création du langage C, la programmation était
de beaucoup plus bas niveau que maintenant. D’autre part, bien maniés, les
pointeurs se révèlent plus rapides que les références,
ce qui est important dans certaines situations.</p>
        </div>
        <div class="sect3">
          <h3 class="title">c. <var style="display:none"> Allocation de mémoire</var>Allocation de mémoire</h3>
          <p class="defaut">Nous l’avons vu, le langage C++ a
conservé les mécanismes du langage C, tout en
cherchant à en améliorer certains. La mémoire
fait partie de ceux-là.</p>
          <p class="defaut">Il existe deux façons de réserver
de la mémoire : en demandant au système, ou bien
en utilisant des instructions du langage. La différence
est subtile, mais cruciale.</p>
          <p class="defaut">Dans l’approche système, mise au
point par le langage C, nous disposons d’une fonction <span class="courier11"><var style="display:none"> malloc()</var>malloc()</span> chargée de réserver
des octets. Cette fonction demande au système d’allouer
une plage de n octets, que l’on interprétera par la suite comme étant
une plage de valeurs d’un type donné, au moyen d’un transtypage.
 Comme c’est le système qui a alloué cette mémoire,
il est également nécessaire de la lui rendre au
moyen de la fonction <span class="courier11"><var style="display:none"> free()</var>free()</span> qui
admet un pointeur sur <span class="courier11">void</span>, autrement
dit, un pointeur de n’importe quel type.</p>
          <p class="defaut">Lorsque l’on utilise les instructions <span class="courier_gras"><var style="display:none"> new</var>new</span> et <span class="courier_gras"><var style="display:none"> delete</var>delete</span>,
le langage adapte sa gestion&nbsp;de la mémoire en
fonction du type réservé. Aucun transtypage n’est nécessaire,
ce qui simplifie la syntaxe.</p>
          <p class="defaut">Dans les faits, avec les compilateurs modernes,
la fonction malloc() et l’instruction new partagent le même
espace mémoire, appelé le tas, pour effectuer leurs
réservations. Toutefois, les gestionnaires d’allocations
n’étant pas les mêmes, il faut veiller à désallouer
la mémoire avec le moyen qui correspond : <span class="courier11">free()</span> pour rendre la mémoire
allouée par <span class="courier11">malloc()</span>, <span class="courier11">delete()</span> pour rendre la mémoire
obtenue par <span class="courier11">new</span>.</p>
          <p class="defaut">Si vous développez un nouveau programme
C++, privilégiez l’instruction <span class="courier_gras">new</span>. La fonction <span class="courier11">malloc()</span> doit être réservée à la
portabilité des anciens programmes&nbsp;C. Ceci dit,
il existe des cas où il faut employer une fonction pour allouer
de la mémoire ayant un accès partagé :
le Presse-papiers sous Windows,&nbsp;une zone de mémoire
partagée sous Unix...</p>
          <p><span class="bridgehead_niv4">Allocation par <var style="display:none"> malloc()</var>malloc()</span></p>
          <p class="defaut">La fonction <span class="courier11">malloc()</span> est
déclarée dans l’en-tête <span class="courier11">&lt;memory.h&gt;</span>. D’autres en-têtes
peuvent convenir, comme <span class="courier11">&lt;stdlib.h&gt;</span>.</p>
          <p class="defaut">Cette fonction est déclarée
selon le prototype suivant : </p>
          <pre class="programlisting">void* malloc(int n);
</pre>
          <p class="defaut">La fonction est chargée d’allouer
n octets dans la mémoire du système (en fait, celle
du processus). Elle retourne l’adresse de cette plage sous la forme
d’un pointeur sur void.</p>
          <p class="defaut">Si la réservation ne peut être
satisfaite, la fonction renvoie 0, l’adresse 0, qui est considérée
comme inaccessible. Pour éviter d’employer une valeur littérale aussi évocatrice,
les concepteurs du langage C ont imaginé la macro NULL :NULL</p>
          <pre class="programlisting">#define NULL ((void*)0)
</pre>
          <p class="defaut">Si la réservation est satisfaite,
le programmeur doit convertir le pointeur void* dans un
type approprié : </p>
          <pre class="programlisting">char*p;&nbsp;
 &nbsp;p=(char*) malloc(15); // alloue 15 char&nbsp;
 &nbsp;if(p==NULL)&nbsp;
 &nbsp; &nbsp;printf("erreur d’allocation");
</pre>
          <p class="defaut">Nombre de compilateurs accepteraient l’écriture <span class="courier11">p=malloc(15)</span>, mais par rigueur&nbsp;d’écriture,
on doit s’efforcer d’effectuer un transtypage par coercition, en
indiquant que l’on prend la responsabilité d’interpréter
cette zone comme étant une zone de 15 char. </p>
          <p class="defaut">Par ailleurs, si le type est plus large que
le char, il faut employer l’opérateur <span class="courier11">sizeof()</span> pour
réserver suffisamment d’octets : </p>
          <pre class="programlisting">double*d=(double*) malloc(30*sizeof(double)); // alloue 30 double
</pre>
          <p class="defaut">Lorsque le bloc est alloué, on s’en
sert comme n’importe quel tableau, en utilisant la notation de son
choix : *d, d[] ou *(d+i).</p>
          <p class="defaut">Lorsque la mémoire n’est plus utile,
le bloc doit être rendu au système par l’intermédiaire&nbsp;de
la fonction free() : </p>
          <pre class="programlisting">free(d);
</pre>
          <p><span class="bridgehead_niv4">Allocation par <var style="display:none"> new</var>new</span></p>
          <p class="defaut">L’allocation par <span class="courier11">new</span> sera
pour l’instant réservée aux tableaux. Lorsque
nous traiterons l’instanciation, l’opérateur <span class="courier11">new</span> accomplira un autre rôle,
essentiel.</p>
          <p class="defaut">La syntaxe générale de l’instruction <span class="courier11">new</span> est :</p>
          <pre class="programlisting">type* new type &lt; [taille] &gt;
</pre>
          <p class="defaut">Autrement dit, l’opérateur new renvoie
le pointeur vers le type alloué. La taille est optionnelle,
l’unité est la valeur par défaut.</p>
          <p class="defaut">Voici quelques exemples d’allocation par l’opérateur
new : </p>
          <div class="table">
            <table class="informaltable" style="max-width:90%" align="left" border="1" bordercolor="black" width="90%">
              <colgroup>
                <col title="1" width="31.25%">
                <col title="2" width="68.75%">
              </colgroup>
              <tbody class="tbody">
                <tr class="RowBody">
                  <td class="entry" style="text-align:left;vertical-align:top;">
                    <p class="tableau_texte">
                      </p><pre class="literallayout">char*p;
p=new char[15];
</pre>
                    <p></p>
                  </td>
                  <td class="entry" style="text-align:left;vertical-align:top;">
                    <p class="tableau_texte">Allouer 15 char</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:left;vertical-align:top;">
                    <p class="tableau_texte">
                      </p><pre class="literallayout">double*d;
d=new double[30];
</pre>
                    <p></p>
                  </td>
                  <td class="entry" style="text-align:left;vertical-align:top;">
                    <p class="tableau_texte">Allouer 30 double</p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:left;vertical-align:top;">
                    <p class="tableau_texte">
                      </p><pre class="literallayout">string * s;
s=new string;
</pre>
                    <p></p>
                  </td>
                  <td class="entry" style="text-align:left;vertical-align:top;">
                    <p class="tableau_texte">Allouer une chaîne à l’aide
de la classe string (cf.&nbsp;Instanciation&nbsp;de classes)</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p class="defaut">Une fois le bloc alloué par <span class="courier11">new</span>, on l’utilise avec les mêmes
notations que lorsqu’il a été réservé par <span class="courier11">malloc()</span>. En revanche, le bloc doit être
impérativement libéré à l’aide
de l’instruction <span class="courier11">delete</span> :</p>
          <pre class="programlisting">delete(p);
</pre>
        </div>
        <div class="sect3">
          <h3 class="title">d. <var style="display:none"> Arithmétique des pointeurs</var>Arithmétique des pointeurs</h3>
          <p class="defaut">Lorsque nous déplaçons un
pointeur, par incrément ou par addition, combien d’octets
sont balayés ? Si le pointeur est char*, la réponse
est simple :</p>
          <pre class="programlisting">char*p;&nbsp;
char c;&nbsp;
 &nbsp; &nbsp; p=&amp;x;&nbsp;
 &nbsp; &nbsp; p++; &nbsp;// passe à l’adresse suivante (en octets)
</pre>
          <p class="defaut">De même, lorsque l’on accède à la
valeur désignée par un pointeur, combien d’octets
sont lus ou écrits ? Encore une fois cela dépend
du type du pointeur.</p>
          <p class="defaut">Prenons l’exemple suivant :</p>
          <pre class="programlisting">float*p;&nbsp;
char*t;&nbsp;
 &nbsp; &nbsp;t=new char[12];&nbsp;
 &nbsp; &nbsp;for(int i=0; i&lt;10; i++)&nbsp;
 &nbsp; &nbsp; t[i]=1;&nbsp;
 &nbsp; &nbsp;p=(float*)t; // peu rigoureux mais légal&nbsp;
 &nbsp; &nbsp;*(p+1)=0;
</pre>
          <p class="defaut">En sortie de ce programme, quel est l’état
du tableau t ? L’écriture *(p+1)=0 a
impacté 4 octets, à compter de la cinquième
position, comme le montre l’illustration ci-après :</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata" alt="images/02ppn07.png" src="../download/b844323e-b2d6-4ead-a5c6-57dbf2815b15/images\02ppn07.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAABKTGl2cmVzIGdyYXR1aXRzIGNvZGVyQHR1eGZhbWlseS5vcmcgLSA5OTRjYzFjMS02YjIwLTQ2YTUtODAxNC02YjU3ODNkYjU5MTB%2b7H31jfXQiAsA"></div>
          </div>
          <p class="defaut">Lorsque l’on compte en <span class="courier11">float</span>,
il faut multiplier par 4 tous les déplacements. L’écriture
impacte aussi 4 octets au lieu d’un seul, et ce, même si
la zone avait été réservée comme
une zone de char.</p>
          <p class="defaut">Cette règle de calcul s’appelle l’arithmétique
des pointeurs, et doit être appliquée avec la
plus grande rigueur qui soit.</p>
        </div>
        <div class="sect3">
          <h3 class="title">e. <var style="display:none"> Pointeur:de pointeur</var>Pointeurs de pointeurs</h3>
          <p class="defaut">Maintenant que nous connaissons bien les pointeurs,
pourquoi ne pas définir un pointeur qui désigne
une variable de type pointeur ? Cette opération est finalement
assez courante, si l’on considère que les littérales
de chaînes sont des tableaux de <span class="courier11">char</span>,
autrement dit des pointeurs de <span class="courier11">char (char*)</span>.
La fonction <span class="courier11">main(),</span> admettant comme
paramètre un tableau de chaînes, reçoit en
réalité un pointeur de pointeurs.</p>
          <p class="defaut">Les pointeurs de pointeurs ne sont finalement
pas si complexes, ils constituent simplement une indirection de
plus. Il ne faut pas en abuser et, afin de simplifier au maximum
les notations, on privilégiera les notations de type tableau.&nbsp;</p>
          <pre class="programlisting">char**argv; &nbsp;// un pointeur de pointeurs de type char&nbsp;
char* argv[]; // un tableau de pointeurs de type char
</pre>
          <p class="defaut">Bien entendu, les notations destinées
aux pointeurs usuels restent applicables aux pointeurs de pointeurs
:</p>
          <pre class="programlisting">char*p; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// un pointeur de type char&nbsp;
char* *pp; &nbsp; &nbsp; &nbsp; // un pointeur de pointeur de type char&nbsp;
&nbsp;
pp=&amp;p; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // &amp;p=adresse de p. pp désigne p&nbsp;
&nbsp;
*pp="salut"; &nbsp; &nbsp; // autrement dit, p="salut"&nbsp;
**pp=’S’; &nbsp; &nbsp; &nbsp; &nbsp;// autrement dit, *p=’S’&nbsp;
&nbsp;
printf("%s",p); &nbsp;// affiche Salut
</pre>
        </div>
        <div class="sect3"><var style="display:none"> Pointeur:de fonction</var><h3 class="title">f. Pointeurs de fonctions</h3>
          <p class="defaut">Puisque les instructions définissant
une fonction sont, à l’instar des variables, rangées
dans la mémoire, nous pouvons admettre que les fonctions
sont en fait des adresses : celles de leur première instruction.
Partant de là, il devient possible de définir
des pointeurs de fonctions pour appeler - indirectement - certaines
d’entre elles.</p>
          <p class="defaut">Il apparaît que les pointeurs de
fonctions sont employés dans quelques situations&nbsp;particulières.
Tout d’abord, un pointeur de fonction rend certains algorithmes
génériques. Prenons l’exemple de l’algorithme
de tri rapide. Celui-ci reste le même, que l’on cherche à trier
un ensemble d’entiers, un ensemble de booléens, ou des
objets de nature variée. Pour rendre le programme indépendant&nbsp;du
type de données à trier, il est possible d’utiliser
un pointeur vers une fonction qui admette deux valeurs et qui indique
laquelle est la plus grande.</p>
          <p class="defaut">On rencontre également des pointeurs
de fonctions lorsque l’on applique des méthodes à des
objets. Le chapitre sur l’adressage relatif nous donnera plus d’informations à ce
sujet.</p>
          <p class="defaut">Enfin, il n’est pas rare de fournir à un
module "système" un pointeur vers une fonction qui sera
appelée lorsque surviendra un événement
particulier. On désigne&nbsp;ce mécanisme
par le terme de fonctions callback (rappelables).</p>
          <p><span class="bridgehead_niv4">Utilisation de pointeurs de fonctions
pour rendre les <var style="display:none"> Algorithme:générique</var>algorithmes génériques</span></p>
          <p class="defaut">Dans le but d’illustrer cette approche, nous
proposons d’étudier l’algorithme du tri rapide.</p>
          <p class="defaut">Pour comprendre cet algorithme, nous commençons
par partitionner un tableau. Un tableau de valeurs, par exemple
des entiers, est partitionné autour d’une valeur pivot
en plaçant à gauche de ce pivot toutes les valeurs
inférieures et à droite, toutes les valeurs supérieures.</p>
          <p class="defaut">Tout d’abord le tableau d’origine, avec un
pivot (en gras), choisi arbitrairement au milieu :</p>
          <div class="table">
            <table class="informaltable" style="max-width:90%" align="left" border="1" bordercolor="black" width="90%">
              <colgroup>
                <col title="1" width="NaN%">
                <col title="2" width="NaN%">
                <col title="3" width="NaN%">
                <col title="4" width="NaN%">
                <col title="5" width="NaN%">
                <col title="6" width="NaN%">
                <col title="7" width="NaN%">
                <col title="8" width="NaN%">
                <col title="9" width="NaN%">
              </colgroup>
              <tbody class="tbody">
                <tr class="RowBody">
                  <td class="entry" style="text-align:center;vertical-align:top;">
                    <p class="tableau_texte">2</p>
                  </td>
                  <td class="entry" style="text-align:center;vertical-align:top;">
                    <p class="tableau_texte">8</p>
                  </td>
                  <td class="entry" style="text-align:center;vertical-align:top;">
                    <p class="tableau_texte">3</p>
                  </td>
                  <td class="entry" style="text-align:center;vertical-align:top;">
                    <p class="tableau_texte">7</p>
                  </td>
                  <td class="entry" style="text-align:center;vertical-align:top;">
                    <p class="tableau_texte"><b>5</b></p>
                  </td>
                  <td class="entry" style="text-align:center;vertical-align:top;">
                    <p class="tableau_texte">9</p>
                  </td>
                  <td class="entry" style="text-align:center;vertical-align:top;">
                    <p class="tableau_texte">3</p>
                  </td>
                  <td class="entry" style="text-align:center;vertical-align:top;">
                    <p class="tableau_texte">10</p>
                  </td>
                  <td class="entry" style="text-align:center;vertical-align:top;">
                    <p class="tableau_texte">3</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p class="defaut">Voilà maintenant le tableau partitionné.
Le pivot peut avoir changé de place.</p>
          <div class="table">
            <table class="informaltable" style="max-width:90%" align="left" border="1" bordercolor="black" width="90%">
              <colgroup>
                <col title="1" width="NaN%">
                <col title="2" width="NaN%">
                <col title="3" width="NaN%">
                <col title="4" width="NaN%">
                <col title="5" width="NaN%">
                <col title="6" width="NaN%">
                <col title="7" width="NaN%">
                <col title="8" width="NaN%">
                <col title="9" width="NaN%">
              </colgroup>
              <tbody class="tbody">
                <tr class="RowBody">
                  <td class="entry" style="text-align:center;vertical-align:top;">
                    <p class="tableau_texte">2</p>
                  </td>
                  <td class="entry" style="text-align:center;vertical-align:top;">
                    <p class="tableau_texte">3</p>
                  </td>
                  <td class="entry" style="text-align:center;vertical-align:top;">
                    <p class="tableau_texte">3</p>
                  </td>
                  <td class="entry" style="text-align:center;vertical-align:top;">
                    <p class="tableau_texte"><b>5</b></p>
                  </td>
                  <td class="entry" style="text-align:center;vertical-align:top;">
                    <p class="tableau_texte">7</p>
                  </td>
                  <td class="entry" style="text-align:center;vertical-align:top;">
                    <p class="tableau_texte">9</p>
                  </td>
                  <td class="entry" style="text-align:center;vertical-align:top;">
                    <p class="tableau_texte">8</p>
                  </td>
                  <td class="entry" style="text-align:center;vertical-align:top;">
                    <p class="tableau_texte">10</p>
                  </td>
                  <td class="entry" style="text-align:center;vertical-align:top;">
                    <p class="tableau_texte">3</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p class="defaut">L’algorithme du tri rapide réitère
cette partition, à gauche et à droite du pivot, récursivement.
Finalement, nous récupérons un tableau complètement
trié.</p>
          <p class="defaut">Voici pour commencer une implémentation
fonctionnant pour un tableau d’entiers. Nous vous encourageons à la
tester telle quelle si vous n’êtes pas familiarisé&nbsp;avec
cet algorithme :</p>
          <pre class="programlisting">// chapitre 1 partition.cpp : définit le point&nbsp;
// d’entrée pour l’application console.&nbsp;
//&nbsp;
&nbsp;
int partition(int* T,int m,int d)&nbsp;
{ &nbsp;&nbsp;
 &nbsp;// valeur pivot, variable d’échange&nbsp;
 &nbsp;int v,aux; &nbsp; &nbsp;&nbsp;
 &nbsp;int m1=m,d1=d;&nbsp;
 &nbsp;// initialisation&nbsp;
 &nbsp;v=T[m+(d-m)/2];&nbsp;
&nbsp;
 &nbsp;// tant que les index ne se croisent pas&nbsp;
 &nbsp;while(m&lt;d)&nbsp;
 &nbsp;{&nbsp;
 &nbsp; &nbsp;// rechercher une valeur inférieure à droite&nbsp;
 &nbsp; &nbsp;while(m&lt;d &amp;&amp; T[d]&gt;v)&nbsp;
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;d--;&nbsp;
 &nbsp; &nbsp;// rechercher une valeur supérieure à gauche&nbsp;
 &nbsp; &nbsp;while(m&lt;d &amp;&amp; T[m]&lt;v)&nbsp;
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;m++;&nbsp;
 &nbsp; &nbsp;if(m&gt;=d)&nbsp;
 &nbsp; &nbsp; &nbsp; &nbsp; break;&nbsp;
 &nbsp; &nbsp; &nbsp;&nbsp;
 &nbsp; &nbsp;if(T[m] != T[d])&nbsp;
 &nbsp; &nbsp;{ &nbsp;// échange&nbsp;
 &nbsp; &nbsp; &nbsp; aux=T[d];&nbsp;
 &nbsp; &nbsp; &nbsp; T[d]=T[m];&nbsp;
 &nbsp; &nbsp; &nbsp; T[m]=aux;&nbsp;
 &nbsp; &nbsp;} &nbsp;
 &nbsp; &nbsp; else&nbsp;
 &nbsp; &nbsp; &nbsp;d--;&nbsp;
 &nbsp;}&nbsp;
&nbsp;
 &nbsp;return m;&nbsp;
}&nbsp;
&nbsp;
void tri_aux(int* T,int m,int d)&nbsp;
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
 &nbsp;if(m&gt;=d)&nbsp;
 &nbsp; &nbsp;return; &nbsp; &nbsp; &nbsp;// rien à trier&nbsp;
&nbsp;
 &nbsp;int k=partition(T,m,d); // partitionne entre m et d&nbsp;
 &nbsp;tri_aux(T,m,k-1); &nbsp; &nbsp;// tri à gauche&nbsp;
 &nbsp;tri_aux(T,k+1,d); &nbsp; &nbsp;// tri à droite&nbsp;
}&nbsp;
&nbsp;
void tri(int* T,int length)&nbsp;
{&nbsp;
 &nbsp;tri_aux(T,0,length-1);&nbsp;
}&nbsp;
&nbsp;
void afficher(int T[],int m,int d)&nbsp;
{&nbsp;
 &nbsp;// affichage du tableau à chaque étape&nbsp;
 &nbsp;for(int i=m; i&lt;=d; i++)&nbsp;
 &nbsp; &nbsp; &nbsp;printf("%d,",T[i]);&nbsp;
 &nbsp;printf("\n");&nbsp;
}&nbsp;
&nbsp;
int main()&nbsp;
{&nbsp;
 &nbsp;int tab[]={ 5,1,7,2,8,4,9,13};&nbsp;
 &nbsp;tri(tab,8);&nbsp;
 &nbsp;afficher(tab,0,7);&nbsp;
 &nbsp;return 0;&nbsp;
}
</pre>
          <p class="defaut">Nous proposons maintenant une implémentation
C++ du tri rapide, prenant en paramètres
un tableau à trier, des indices nécessaires au
fonctionnement de l’algorithme, plus deux pointeurs de fonction.
L’un désigne une fonction de comparaison, l’autre une fonction
d’échange.</p>
          <p class="defaut">Voici tout d’abord, la définition
des pointeurs de fonction. Comme l’écriture est un peu
lourde, on a souvent recours à la définition d’alias
de type (typedef)&nbsp;:</p>
          <pre class="programlisting">typedef void (*pf_echange)(void*,int,int);&nbsp;
typedef int (*pf_comp)(void*,int,int);
</pre>
          <p class="defaut">Le premier modèle de fonction, <span class="courier11">pf_echange</span>, caractérise
la signature d’une fonction ne renvoyant rien et admettant un tableau
de <span class="courier11">void</span> (tout type de valeur,&nbsp;en
fait), ainsi que deux entiers.</p>
          <p class="defaut">Le second modèle, <span class="courier11">pf_comp</span>, admet les mêmes
paramètres mais renvoie un entier, résultat de
la comparaison entre deux valeurs. Dans les deux cas, les entiers&nbsp;admis
comme paramètres sont les index des valeurs du tableau, à comparer&nbsp;ou à échanger,
selon le cas.</p>
          <p class="defaut">Il faut maintenant implémenter deux
fonctions respectant ces signatures : </p>
          <pre class="programlisting">void int_echange(void*t,int p1,int p2)&nbsp;
{&nbsp;
 &nbsp;int*T=(int*)t; // transtypage (cast)&nbsp;
 &nbsp;int aux=T[p1];&nbsp;
 &nbsp;T[p1]=T[p2];&nbsp;
 &nbsp;T[p2]=aux;&nbsp;
}&nbsp;
&nbsp;
int int_compare(void*t,int p1,int p2)&nbsp;
{&nbsp;
 &nbsp;int v1,v2;&nbsp;
 &nbsp;int*T=(int*)t; // transtypage (cast)&nbsp;
 &nbsp;v1=(int) T[p1];&nbsp;
 &nbsp;v2=(int) T[p2];&nbsp;
 &nbsp;&nbsp;
 &nbsp;return v1-v2;&nbsp;
}
</pre>
          <p class="defaut">Jusqu’à présent, nous n’avons
pas d’autres moyens d’être indépendant vis-à-vis des
types que d’utiliser un pointeur sur <span class="courier11">void</span>.
Ce qui explique le transtypage un peu brutal, le <span class="courier11">void*</span> étant promu
en <span class="courier11">int*</span>.</p>
          <p class="defaut">Il ne nous reste plus qu’à aménager
le programme existant pour travailler avec ces fonctions, par l’entremise
de pointeurs :</p>
          <pre class="programlisting">// l’algorithme devenu général&nbsp;
int partition(void* T,int m,int d,pf_echange fswap,pf_comp fcomp)&nbsp;
{&nbsp;
 &nbsp;// valeur pivot, variable d’échange&nbsp;
 &nbsp;int pv;&nbsp;
 &nbsp;int m1=m,d1=d;&nbsp;
 &nbsp;// initialisation&nbsp;
 &nbsp;pv=m+(d-m)/2; &nbsp;// position du pivot&nbsp;
&nbsp;
 &nbsp;// tant que les index ne se croisent pas&nbsp;
 &nbsp;while(m&lt;d)&nbsp;
 &nbsp;{&nbsp;
 &nbsp; &nbsp;// rechercher une valeur inférieure à droite&nbsp;
 &nbsp; &nbsp;while(m&lt;d &amp;&amp; (*fcomp)(T,d,pv)&gt;0)&nbsp;
 &nbsp; &nbsp; &nbsp; d--;&nbsp;
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
 &nbsp; &nbsp;// rechercher une valeur supérieure à gauche&nbsp;
 &nbsp; &nbsp;while(m&lt;d &amp;&amp; (*fcomp)(T,m,pv)&lt;0)&nbsp;
 &nbsp; &nbsp; &nbsp;m++;&nbsp;
&nbsp;
 &nbsp; &nbsp;if(m&gt;=d)&nbsp;
 &nbsp; &nbsp; &nbsp;break;&nbsp;
&nbsp;
 &nbsp; &nbsp;if((*fcomp)(T,m,d)!=0)&nbsp;
 &nbsp; &nbsp;{ &nbsp;// échange&nbsp;
 &nbsp; &nbsp; &nbsp;(*fswap)(T,m,d);&nbsp;
 &nbsp; &nbsp;}&nbsp;
 &nbsp; &nbsp; else&nbsp;
 &nbsp; &nbsp; &nbsp;d--;&nbsp;
 &nbsp;}&nbsp;
&nbsp;
 &nbsp;return m;&nbsp;
}&nbsp;
&nbsp;
void tri_aux(int* T,int m,int d,pf_echange fswap,pf_comp fcomp)&nbsp;
{&nbsp;
 &nbsp;if(m&gt;=d)&nbsp;
 &nbsp; &nbsp;return; &nbsp; &nbsp; &nbsp;// rien à trier&nbsp;
 &nbsp;int k=partition(T,m,d,fswap,fcomp); // partitionne entre m et d&nbsp;
 &nbsp;tri_aux(T,m,k-1,fswap,fcomp); &nbsp; &nbsp;// tri à gauche&nbsp;
 &nbsp;tri_aux(T,k+1,d,fswap,fcomp); &nbsp; &nbsp;// tri à droite&nbsp;
}&nbsp;
&nbsp;
void tri(int* T,int length,pf_echange fswap,pf_comp fcomp)&nbsp;
{&nbsp;
 &nbsp;tri_aux(T,0,length-1,fswap,fcomp);&nbsp;
}&nbsp;
 &nbsp;&nbsp;
void afficher(int T[],int m,int d)&nbsp;
{&nbsp;
 &nbsp;// affichage du tableau à chaque étape&nbsp;
 &nbsp;for(int i=m; i&lt;=d; i++)&nbsp;
 &nbsp; &nbsp; &nbsp;printf("%d,",T[i]);&nbsp;
 &nbsp;printf("\n");&nbsp;
}&nbsp;
&nbsp;
int main()&nbsp;
{&nbsp;
 &nbsp;int tab[]={ 5,1,7,2,8,4,9,13};&nbsp;
 &nbsp;tri(tab,8,&amp;int_echange,&amp;int_compare);&nbsp;
 &nbsp;afficher(tab,0,7);&nbsp;
 &nbsp;return 0;&nbsp;
}
</pre>
          <p class="defaut">Au passage, nous relevons que les notations
associées aux pointeurs de variables&nbsp;restent applicables
aux pointeurs de fonctions :</p>
          <div class="table">
            <table class="informaltable" style="max-width:90%" align="left" border="1" bordercolor="black" width="90%">
              <colgroup>
                <col title="1" width="29.688430244096054%">
                <col title="2" width="70.31156975590396%">
              </colgroup>
              <tbody class="tbody">
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">&amp;int_echange</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">adresse de la fonction <span class="courier11">int_echange()</span></p>
                  </td>
                </tr>
                <tr class="RowBody">
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte"><span class="courier11">(*fcomp)(T,m,d)</span></p>
                  </td>
                  <td class="entry" style="text-align:justify;vertical-align:top;">
                    <p class="tableau_texte">Contenu à l’adresse <span class="courier11">fcomp</span>, autrement dit la fonction désignée
par <span class="courier11">fcomp</span> est appelée avec
les paramètres (<span class="courier11">T</span>,<span class="courier11">m</span>,<span class="courier11">d</span>).</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p><span class="bridgehead_niv4"><var style="display:none"> Fonction:callback</var>Fonctions callback</span></p>
          <p class="defaut">L’API (<span class="italic">Application
Programming Interface</span>) standard du C++ propose
peu de fonctions callback. Pour les systèmes graphiques,
comme Windows, c’est au contraire monnaie courante. Les gestionnaires
d’événements associés à un clic sur
un bouton sont souvent des fonctions callback.</p>
          <p class="defaut">Dans ce type de situation, nous avons généralement
un système d’enregistrement. Pour un événement
donné - un clic sur un bouton par exemple&nbsp;-,
une ou plusieurs fonctions sont enregistrées.</p>
          <p class="defaut">Lorsque l’événement survient,
chacune de ces fonctions est appelée dans le but d’accomplir
un travail spécifique - ouvrir une fenêtre,
réaliser un calcul...</p>
          <p class="defaut">Nous pouvons simuler cette approche à l’aide
d’un petit programme. Il est constitué d’une partie système
et d’une partie application. La partie système possède
un dispositif pour enregistrer des gestionnaires d’événements,
ainsi qu’une fonction qui scrute le clavier. Lorsque celui-ci est
sollicité, tous les gestionnaires (ce sont des fonctions)
sont appelés avec un argument représentant la
touche pressée. </p>
          <pre class="programlisting">// &nbsp;partie &nbsp;système&nbsp;
#include &nbsp;&lt;conio.h&gt;&nbsp;
&nbsp;
typedef &nbsp;void &nbsp;(*pf_key_press)(int &nbsp;key);&nbsp;
&nbsp;
pf_key_press*gestionnaires;&nbsp;
int &nbsp;nb_gestionnaires;&nbsp;
&nbsp;
void &nbsp;init()&nbsp;
{&nbsp;
 &nbsp; &nbsp;gestionnaires=new &nbsp;pf_key_press[10]; &nbsp; &nbsp;// &nbsp;10 &nbsp;gestionnaires &nbsp;max&nbsp;
 &nbsp; &nbsp;nb_gestionnaires=0;&nbsp;
}&nbsp;
&nbsp;
void &nbsp;enregistrer(pf_key_press &nbsp;gestionnaire)&nbsp;
{&nbsp;
 &nbsp; &nbsp;gestionnaires[nb_gestionnaires++]=gestionnaire;&nbsp;
}&nbsp;
&nbsp;
void &nbsp;propager_evenement(int &nbsp;touche)&nbsp;
{&nbsp;
 &nbsp;for(int &nbsp;i=0;i&lt;nb_gestionnaires; &nbsp;i++)&nbsp;
 &nbsp;&nbsp;&nbsp;(*gestionnaires[i])(touche); &nbsp;// &nbsp;appelle &nbsp;le &nbsp;gestionnaire&nbsp;
}&nbsp;
&nbsp;
void &nbsp;surveiller_clavier()&nbsp;
{&nbsp;
 &nbsp;int &nbsp;touche;&nbsp;
 &nbsp;do&nbsp;
 &nbsp;&nbsp;&nbsp;{
 &nbsp;&nbsp;&nbsp;while(!_kbhit()); &nbsp;// &nbsp;attend &nbsp;la &nbsp;frappe &nbsp;d’une &nbsp;touche&nbsp;
 &nbsp;&nbsp;&nbsp;touche=_getch(); &nbsp; &nbsp;// &nbsp;récupère &nbsp;la &nbsp;touche&nbsp;
&nbsp;
 &nbsp;&nbsp;&nbsp;propager_evenement(touche);&nbsp;
 &nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;while(touche!=’q’);&nbsp;
}
</pre>
          <p class="defaut">Voilà maintenant la partie application,
qui consiste en deux gestionnaires plus une fonction main() :</p>
          <pre class="programlisting">// partie application&nbsp;
void touche_pressee1(int key)&nbsp;
{&nbsp;
 &nbsp;printf("1. Vous avez pressé la touche %c\n",key);&nbsp;
}&nbsp;
&nbsp;
void touche_pressee2(int key)&nbsp;
{&nbsp;
 &nbsp;printf("2. Vous avez pressé la touche %c\n",key);&nbsp;
}&nbsp;
&nbsp;
// main()&nbsp;
int main(int argc, char* argv[])&nbsp;
{&nbsp;
 &nbsp;// initialisation du système&nbsp;
 &nbsp;init();&nbsp;
&nbsp;
 &nbsp;// ces deux fonctions seront appelées lorsque le clavier&nbsp;
 &nbsp;// sera sollicité&nbsp;
 &nbsp;enregistrer(&amp;touche_pressee1);&nbsp;
 &nbsp;enregistrer(&amp;touche_pressee2);&nbsp;
&nbsp;
 &nbsp;// démarrage&nbsp;
 &nbsp;surveiller_clavier();&nbsp;
 &nbsp;return 0;&nbsp;
}
</pre>
          <p class="defaut">L’exécution du programme peut donner
quelque chose qui ressemble à cela&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata" alt="images/01RI03.png" src="../download/b844323e-b2d6-4ead-a5c6-57dbf2815b15/images\01RI03.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAABKTGl2cmVzIGdyYXR1aXRzIGNvZGVyQHR1eGZhbWlseS5vcmcgLSA5OTRjYzFjMS02YjIwLTQ2YTUtODAxNC02YjU3ODNkYjU5MTB%2b7H31jfXQiAsA"></div>
          </div>
          <p class="defaut">Bien que sommaire, ce programme illustre bien
le fonctionnement des systèmes d’exploitation graphiques
comme Windows ou Mac OS.</p>
        </div>
      </div>
      <div class="sect2">
        <h2 class="title">7. <var style="display:none"> Références</var>Références</h2>
        <p class="defaut">Bien qu’accomplissant le même rôle
que les pointeurs, les références offrent une
syntaxe plus simple et en même temps limitent les risques
d’accès erroné à la mémoire.</p>
        <p class="defaut">Une référence est toujours
associée à une variable, alors qu’un pointeur
peut être modifié via l’arithmétique
des pointeurs.</p>
        <p class="defaut">La syntaxe de définition d’un type
référence utilise le préfixe &amp;, en
remplacement de l’étoile. Par contre, il ne faut pas confondre
ce préfixe avec l’opérateur &amp; qui extrait
l’adresse d’une variable ou d’une fonction.</p>
        <pre class="programlisting">char c; &nbsp;// un caractère&nbsp;
char*p; &nbsp;// un pointeur de char&nbsp;
p=&amp;c; &nbsp; &nbsp;// p désigne c, et &amp;c représente l’adresse de c&nbsp;
char &amp; refc=c; // refc est une référence de char,&nbsp;
refc désigne c
</pre>
        <p class="defaut">Dans cet extrait de code, nous avons défini
une référence de char, refc, désignant
la variable c. Cette référence est devenue un
alias de la variable c, aussi, toute modification amenée
par refc impactera en réalité c, même
en dehors de sa portée :</p>
        <pre class="programlisting">refc++; &nbsp;// incrémente en fait c
</pre>
        <p class="defaut">Comme dans le cas des pointeurs, les références
n’ont de réel intérêt que pour réaliser
des effets de bord. Pour illustrer cet usage, reprenons la fonction
maj() étudiée précédemment.</p>
        <div class="table">
          <table class="informaltable" style="max-width:90%" align="left" border="1" bordercolor="black" width="90%">
            <colgroup>
              <col title="1" width="50%">
              <col title="2" width="50%">
            </colgroup>
            <thead class="thead">
              <tr class="RowHead">
                <td class="entry" style="text-align:center;vertical-align:top;">
                  <p class="tableau_titre">Version <var style="display:none"> Pointeur</var>pointeur</p>
                </td>
                <td class="entry" style="text-align:center;vertical-align:top;">
                  <p class="tableau_titre">Version référence</p>
                </td>
              </tr>
            </thead>
            <tbody class="tbody">
              <tr class="RowBody">
                <td class="entry" style="text-align:left;vertical-align:top;">
                  <p class="tableau_texte">
                    </p><pre class="literallayout">void maj(char* c) 
{  
&nbsp;&nbsp;&nbsp;printf("avant c=%c\n",*c);
&nbsp;&nbsp;&nbsp;if(*c&gt;=’a’ &amp;&amp; *c&lt;=’z’)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*c=*c-(’a’-’A’); 
&nbsp;&nbsp;&nbsp;printf("après c=%c\n",*c); 
}
</pre>
                  <p></p>
                </td>
                <td class="entry" style="text-align:left;vertical-align:top;">
                  <p class="tableau_texte">
                    </p><pre class="literallayout">void maj(char&amp; c) 
{
&nbsp;&nbsp;&nbsp;printf("avant c=%c\n",c);
&nbsp;&nbsp;&nbsp;if(c&gt;=’a’ &amp;&amp; c&lt;=’z’) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c=c-(’a’-’A’);  
&nbsp;&nbsp;&nbsp;printf("après c=%c\n",&amp;c); 
}
</pre>
                  <p></p>
                </td>
              </tr>
              <tr class="RowBody">
                <td class="entry" style="text-align:left;vertical-align:top;">
                  <p class="tableau_texte">
                    </p><pre class="literallayout">int main() 
{
char x=’a’; 
&nbsp;&nbsp;&nbsp;maj(&amp;x);  
&nbsp;&nbsp;&nbsp;printf("finalement,
x=%c\n",x); 
 &nbsp; &nbsp;return 0; 
}
</pre>
                  <p></p>
                </td>
                <td class="entry" style="text-align:left;vertical-align:top;">
                  <p class="tableau_texte">
                    </p><pre class="literallayout">int main()
{
char x=’a’;
&nbsp;&nbsp;&nbsp;maj(x);
&nbsp;&nbsp;&nbsp;printf("finalement,
x=%c\n",x);  
&nbsp;&nbsp;&nbsp;return 0; 
}
</pre>
                  <p></p>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <p class="defaut">Nous nous rendons compte que la syntaxe par
référence est plus simple que celle proposée
par le style pointeur. L’écriture se rapproche davantage
du passage par valeur et pourtant l’effet de bord - la
modification par une procédure&nbsp;- est
possible.</p>
        <p><span class="bridgehead_niv4">Une plus grande sécurité</span></p>
        <p class="defaut">Les références offrent une
sécurité bien plus grande que les pointeurs, puisque l’adresse
maniée par la référence n’est pas évaluable.
Le pointeur est libre d’être déplacé,
par incrément, addition... La référence étant
toujours, dès sa déclaration, associée à une
variable, les risques d’erreurs sont limités.</p>
        <p><span class="bridgehead_niv4">Les <var style="display:none"> Références:constantes</var>références constantes</span></p>
        <p class="defaut">Les références constantes,
généralement utilisées pour les fonctions,
garantissent que la variable n’est pas modifiée par la
fonction.</p>
        <pre class="programlisting">void fonction_sans_risque(const int &amp; x)&nbsp;
{&nbsp;
 &nbsp;printf("x=%d",x); &nbsp;// ok&nbsp;
 &nbsp;x=4; // erreur&nbsp;
}
</pre>
        <p class="defaut">On peut objecter que l’intérêt
d’une telle méthode est quasi nul. À quoi bon passer
un entier par référence si l’on s’évertue à le
rendre invariable ? Pour un type primitif comme <span class="courier11">int</span>,
la cause est entendue, mais pour un type objet (une classe), les
cas d’application sont nombreux. Les méthodes sont applicables, les
champs sont modifiables, même si la référence
est constante. Le passage par référence autorise
les effets de bord, l’objet n’étant pas copié dans
la pile. D’autre part l’appel est plus rapide puisque la référence
s’assimile à une adresse, ce qui est souvent plus économique
que de recopier tous les champs de l’objet dans la pile.</p>
        <p><span class="bridgehead_niv4"><var style="display:none"> Renvoyer une référence</var>Renvoyer une référence
depuis une fonction</span></p>
        <p class="defaut">Il est tout à fait possible de définir
une fonction qui renvoie une référence. En voici
un exemple :</p>
        <pre class="programlisting">double euro,fs,livre;&nbsp;
double &amp; cours(int pays)&nbsp;
{&nbsp;
 &nbsp;switch(pays)&nbsp;
 &nbsp;{&nbsp;
 &nbsp; &nbsp;case 1:&nbsp;
 &nbsp; &nbsp; &nbsp;return livre;&nbsp;
 &nbsp; &nbsp;case 2 :&nbsp;
 &nbsp; &nbsp; &nbsp;return fs;&nbsp;
 &nbsp; &nbsp;default:&nbsp;
 &nbsp; &nbsp; &nbsp;return euro;&nbsp;
 &nbsp;}&nbsp;
}
</pre>
        <p class="defaut">L’intérêt d’une telle approche
est que tout le monde travaille avec la même valeur.&nbsp;Si
les variables <span class="courier11">euro</span>, <span class="courier11">fs</span> ou <span class="courier11">livre</span> voient
leur valeur modifiée, toutes les fonctions les utilisant
utiliseront les valeurs à jour, la fonction <span class="courier11">cours()</span> ayant transmis une référence
plutôt qu’une valeur. </p>
        <p class="defaut">Cet emploi des références évoque également
l’usage de champs statiques dans une classe, avec certes une syntaxe
un peu différente.</p>
      </div>
      <div class="sect2">
        <h2 class="title">8. <var style="display:none"> Constantes</var>Constantes</h2>
        <div class="sect3">
          <h3 class="title">a. <var style="display:none"> Constantes:symboliques</var>Constantes symboliques</h3>
          <p class="defaut">Le préprocesseur, utilitaire de prétraitement
textuel, remplit trois missions importantes&nbsp;:</p>
          <div class="divliste1">
            <ul class="liste1">
              <li class="liste1">
                <p class="liste1">il inclut les fichiers
désignés par la directive <span class="courier11">#include</span> ;</p>
              </li>
              <li class="liste1">
                <p class="liste1">il évalue la présence
de macros par la directive <span class="courier11">#ifdef</span> ;</p>
              </li>
              <li class="liste1">
                <p class="liste1">il évalue les macros définies
par la directive <span class="courier11">#define</span>.</p>
              </li>
            </ul>
          </div>
          <p class="defaut">Ce préprocesseur travaille en amont
du compilateur. Depuis que les nouveaux langages de programmation
ont abandonné son usage (Java par exemple), il vaut mieux
limiter le nombre de macros définies avec <span class="courier11">#define</span>.</p>
          <p class="defaut">On peut toutefois utiliser cette dernière
directive pour définir des constantes symboliques&nbsp;:</p>
          <pre class="programlisting">#define PI 3.14159265358
</pre>
          <p class="defaut">Dans les fichiers qui ont reçu cette
définition, le préprocesseur remplacera la chaîne
PI par sa valeur textuelle dans toutes ses occurrences qui n’apparaissent pas
dans une chaîne de caractères.</p>
          <pre class="programlisting">#define PI 3.14&nbsp;
double x=PI;&nbsp;
&nbsp;
char*a="Le savant grec Pythagore a découvert PI&nbsp;
sans calculette";
</pre>
          <p class="defaut">Le compilateur reçoit une version
modifiée du dernier fragment&nbsp;:</p>
          <pre class="programlisting">double x=3.14;&nbsp;
&nbsp;
char*a="Le savant grec Pythagore a découvert PI&nbsp;
sans calculette";
</pre>
        </div>
        <div class="sect3">
          <h3 class="title">b. Le type <var style="display:none"> void</var>void</h3>
          <p class="defaut">Aucune variable ne peut être typée
void, pourtant ce type entre dans la classification des types élémentaires,
comme <span class="courier11">int</span>, <span class="courier11">short</span>...</p>
          <p class="defaut">Ce mot clé est utilisé pour
indiquer qu’une fonction ne renvoie rien, c’est une procédure&nbsp;:</p>
          <pre class="programlisting">void afficher(char*s)&nbsp;
{&nbsp;
}
</pre>
          <p class="defaut">On utilisera aussi <span class="courier11">void *</span>,
pointeur sur un type indéterminé. Un transtypage sert
ensuite à convertir ce pointeur dans le type qui convient&nbsp;:</p>
          <pre class="programlisting">void* malloc(int nb_octets) // fonction qui renvoie void*&nbsp;
{ ..}&nbsp;
&nbsp;
char*s=(char*) malloc(15)&nbsp;; // alloue 15 octets
</pre>
          <p class="defaut">Ce système était pour le
C un moindre mal dans sa tentative de supporter la généricité.
Plutôt que d’assimiler l’adresse à un entier - ce
qui se passe de toute façon lorsque l’on parle d’arithmétique
des pointeurs - on dira que <span class="courier11">malloc()</span> alloue
des octets et retourne l’adresse de la zone allouée. Le
type de la zone (int, double...) dépend de l’interprétation
qu’en fait le programmeur. Cette interprétation est précisée
par la conversion d’une valeur <span class="courier11">void*</span> en <span class="courier11">char*</span> dans notre exemple.</p>
        </div>
        <div class="sect3">
          <h3 class="title">c. Les <var style="display:none"> Alias de type</var>alias de type, <var style="display:none"> typedef</var>typedef</h3>
          <p class="defaut">Cet opérateur sert à créer
des alias vers des types exigeant des notations alambiquées.&nbsp;Plutôt
que d’écrire très souvent <span class="courier11">unsigned
char</span>, on préférera déclarer le
type <span class="courier11">uchar</span>&nbsp;:</p>
          <pre class="programlisting">typedef unsigned char uchar ;
</pre>
          <p class="defaut">Par la suite, des variables prendront indifféremment
le type <span class="courier11">unsigned char</span> ou <span class="courier11">uchar</span>&nbsp;:</p>
          <pre class="programlisting">uchar c ; // équivalent à unsigned char c ;
</pre>
        </div>
        <div class="sect3">
          <h3 class="title">d. Constantes et <var style="display:none"> Énumérations</var>énumérations</h3>
          <p class="defaut">Le langage C++ a introduit
le mot clé <span class="courier_gras"><var style="display:none"> const</var>const</span> qui
empêche la modification d’une variable après son
initialisation&nbsp;: </p>
          <pre class="programlisting">const double pi=3.14;
</pre>
          <p class="defaut">Cette notation est commune à d’autres
langages, ce qui la rend bien plus portable&nbsp;que la directive <span class="courier11"><var style="display:none"> #define</var>#define</span>.</p>
          <p class="defaut">Lorsque la valeur numérique d’une
constante importe moins que son libellé, les énumérations
constituent une très bonne solution&nbsp;:</p>
          <pre class="programlisting"><var style="display:none"> enum</var>enum Jour { lundi, mardi, mercredi, jeudi,&nbsp;
vendredi, samedi, dimanche } ;&nbsp;
Jour rendez_vous;&nbsp;
&nbsp;
int main(int argc, char* argv[])&nbsp;
{&nbsp;
 &nbsp;rendez_vous=mercredi;&nbsp;
 &nbsp;return 0;&nbsp;
}
</pre>
          <p class="defaut">Dans cette configuration, la valeur réelle
de mercredi importe peu. C’est le nom de la constante qui est évocateur.</p>
          <p class="defaut">En fait, les énumérations
sont assimilables à un type entier, aussi est-il possible
de fixer la valeur de départ de l’énumération&nbsp;:</p>
          <pre class="programlisting">enum Couleur { Rouge=38, Jaune, Bleu };
</pre>
        </div>
      </div>
    
